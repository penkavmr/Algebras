{VERSION 6 0 "IBM INTEL NT" "6.0" }
{USTYLETAB {CSTYLE "Maple Input" -1 0 "Courier" 0 1 255 0 0 1 0 1 0 0 
1 0 0 0 0 1 }{CSTYLE "2D Math" -1 2 "Times" 0 1 0 0 0 0 0 0 2 0 0 0 0 
0 0 1 }{CSTYLE "2D Comment" 2 18 "" 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 }
{CSTYLE "_cstyle3" -1 256 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 0 0 0 1 }
{CSTYLE "_cstyle4" -1 257 "Courier" 1 12 255 0 0 1 2 1 2 2 1 2 0 0 0 
1 }{CSTYLE "_cstyle5" -1 258 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 0 0 0 1 
}{CSTYLE "_cstyle6" -1 259 "Courier" 1 12 255 0 0 1 2 1 2 2 1 2 0 0 0 
1 }{CSTYLE "_cstyle7" -1 260 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 0 0 0 1 
}{CSTYLE "_cstyle8" -1 261 "Times" 1 18 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }
{CSTYLE "_cstyle9" -1 262 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 0 0 0 1 }
{CSTYLE "_cstyle10" -1 263 "Times" 1 14 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }
{CSTYLE "_cstyle11" -1 264 "Courier" 1 12 255 0 0 1 2 1 2 2 1 2 0 0 0 
1 }{CSTYLE "_cstyle12" -1 265 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 0 0 0 
1 }{CSTYLE "_cstyle13" -1 266 "Courier" 1 12 255 0 0 1 2 1 2 2 1 2 0 
0 0 1 }{CSTYLE "_cstyle14" -1 267 "Times" 1 14 0 0 0 1 2 1 2 2 2 2 0 
0 0 1 }{CSTYLE "_cstyle1" -1 268 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 0 0 
0 1 }{CSTYLE "_cstyle15" -1 269 "Times" 1 18 0 0 0 1 2 1 2 2 2 2 0 0 
0 1 }{CSTYLE "_cstyle16" -1 270 "Times" 1 14 0 0 0 1 2 1 2 2 2 2 0 0 
0 1 }{CSTYLE "_cstyle17" -1 271 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 0 0 
0 1 }{CSTYLE "_cstyle18" -1 272 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 0 0 
0 1 }{CSTYLE "_cstyle19" -1 273 "Courier" 1 12 255 0 0 1 2 1 2 2 1 2 
0 0 0 1 }{CSTYLE "_cstyle20" -1 274 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 
0 0 0 1 }{PSTYLE "Normal" -1 0 1 {CSTYLE "" -1 -1 "Times" 1 12 0 0 0 
1 2 2 2 2 2 2 1 1 1 1 }1 1 0 0 0 0 1 0 1 0 2 2 0 1 }{PSTYLE "_pstyle11
" -1 256 1 {CSTYLE "" -1 -1 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 1 1 1 1 }
1 1 0 0 0 0 2 0 2 0 2 2 0 1 }{PSTYLE "_pstyle12" -1 257 1 {CSTYLE "" 
-1 -1 "Courier" 1 12 255 0 0 1 2 1 2 2 1 2 1 1 1 1 }1 1 0 0 0 0 2 0 2 
0 2 2 0 1 }{PSTYLE "_pstyle13" -1 258 1 {CSTYLE "" -1 -1 "Times" 1 12 
0 0 0 1 2 2 2 2 2 2 1 1 1 1 }1 1 0 0 0 0 2 0 2 0 2 2 0 1 }{PSTYLE "_ps
tyle14" -1 259 1 {CSTYLE "" -1 -1 "Courier" 1 12 255 0 0 1 2 1 2 2 1 
2 1 1 1 1 }1 1 0 0 0 0 2 0 2 0 2 2 0 1 }{PSTYLE "_pstyle15" -1 260 1 
{CSTYLE "" -1 -1 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 1 1 1 1 }1 1 0 0 0 
0 2 0 2 0 2 2 0 1 }{PSTYLE "_pstyle16" -1 261 1 {CSTYLE "" -1 -1 "Time
s" 1 18 0 0 0 1 2 1 2 2 2 2 1 1 1 1 }1 1 0 0 8 4 2 0 2 0 2 2 0 1 }
{PSTYLE "_pstyle70" -1 262 1 {CSTYLE "" -1 -1 "Times" 1 12 0 0 0 1 2 
2 2 2 2 2 1 1 1 1 }1 1 0 0 0 0 2 0 2 0 2 2 0 1 }{PSTYLE "_pstyle71" 
-1 263 1 {CSTYLE "" -1 -1 "Times" 1 14 0 0 0 1 2 1 2 2 2 2 1 1 1 1 }1 
1 0 0 8 2 2 0 2 0 2 2 0 1 }{PSTYLE "_pstyle72" -1 264 1 {CSTYLE "" -1 
-1 "Courier" 1 12 255 0 0 1 2 1 2 2 1 2 1 1 1 1 }1 1 0 0 0 0 2 0 2 0 
2 2 0 1 }{PSTYLE "_pstyle73" -1 265 1 {CSTYLE "" -1 -1 "Times" 1 12 0 
0 0 1 2 2 2 2 2 2 1 1 1 1 }1 1 0 0 0 0 2 0 2 0 2 2 0 1 }{PSTYLE "_psty
le74" -1 266 1 {CSTYLE "" -1 -1 "Courier" 1 12 255 0 0 1 2 1 2 2 1 2 
1 1 1 1 }1 1 0 0 0 0 2 0 2 0 2 2 0 1 }{PSTYLE "_pstyle75" -1 267 1 
{CSTYLE "" -1 -1 "Times" 1 14 0 0 0 1 2 1 2 2 2 2 1 1 1 1 }1 1 0 0 8 
2 2 0 2 0 2 2 0 1 }{PSTYLE "_pstyle9" -1 268 1 {CSTYLE "" -1 -1 "Times
" 1 12 0 0 0 1 2 2 2 2 2 2 1 1 1 1 }1 1 0 0 0 0 2 0 2 0 2 2 0 1 }
{PSTYLE "_pstyle76" -1 269 1 {CSTYLE "" -1 -1 "Times" 1 18 0 0 0 1 2 
1 2 2 2 2 1 1 1 1 }1 1 0 0 8 4 2 0 2 0 2 2 0 1 }{PSTYLE "_pstyle77" 
-1 270 1 {CSTYLE "" -1 -1 "Times" 1 14 0 0 0 1 2 1 2 2 2 2 1 1 1 1 }1 
1 0 0 8 2 2 0 2 0 2 2 0 1 }{PSTYLE "_pstyle78" -1 271 1 {CSTYLE "" -1 
-1 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 1 1 1 1 }1 1 0 0 0 0 2 0 2 0 2 2 
0 1 }{PSTYLE "_pstyle79" -1 272 1 {CSTYLE "" -1 -1 "Times" 1 12 0 0 0 
1 2 2 2 2 2 2 1 1 1 1 }1 1 0 0 0 0 2 0 2 0 2 2 0 1 }{PSTYLE "_pstyle80
" -1 273 1 {CSTYLE "" -1 -1 "Courier" 1 12 255 0 0 1 2 1 2 2 1 2 1 1 
1 1 }1 1 0 0 0 0 2 0 2 0 2 2 0 1 }{PSTYLE "_pstyle81" -1 274 1 
{CSTYLE "" -1 -1 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 1 1 1 1 }1 1 0 0 0 
0 2 0 2 0 2 2 0 1 }}
{SECT 0 {PARA 0 "" 0 "" {TEXT -1 0 "" }}{PARA 256 "" 0 "" {TEXT 256 
110 "The first  PARITY elements in the basis of the vector space will \+
be considered even, and all the rest are odd." }}{EXCHG {PARA 257 "> \+
" 0 "" {MPLTEXT 1 257 23 "PARITY:=0:DIMENSION:=1:" }}}{PARA 256 "" 0 "
" {TEXT 256 51 "The parity of an element is defined using the above" }
}{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 1 257 77 "parity_elem:=proc(i::po
sint) \nif i<=PARITY then \nreturn(0)\nfi;\nreturn(1)\nend:" }}}{PARA 
256 "" 0 "" {TEXT 256 42 "The following computes -1 to the argument." 
}}{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 1 257 25 "sgn:=proc(a)\n(-1)^a;
\nend:" }}}{PARA 258 "" 0 "" {TEXT 258 35 "The following defines even \+
and odd." }}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 15 "ODD:=1:EVEN:
=0:" }}}{PARA 256 "" 0 "" {TEXT 256 74 "This is the Kronecker delta fu
nction.  It returns 1 if i = j and 0 if not." }}{EXCHG {PARA 257 "> " 
0 "" {MPLTEXT 1 257 62 "deltaij:=proc(i,j)\nif i=j then \nreturn(1);\n
fi;\nreturn(0);\nend:" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 19 "_M
axSols:=infinity:" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}
{SECT 0 {PARA 261 "" 0 "" {TEXT 261 17 "Tensor Operations" }}{PARA 
262 "" 0 "" {TEXT 262 53 "A basic element of the tensor algebra is of \+
the form " }{XPPEDIT 18 0 "e_I" "6#%$e_IG" }{TEXT 262 36 "  where I is
 a list of indices ....." }}{SECT 0 {PARA 263 "" 0 "" {TEXT 263 12 "Te
nsor Bases" }}{PARA 256 "" 0 "" {TEXT 256 43 "The base for the one ten
sor is given below." }}{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 1 257 8 "ON
E:=[]:" }}}{PARA 256 "" 0 "" {TEXT 256 58 "The command below multiplie
s the bases for a vector space." }}{EXCHG {PARA 257 "> " 0 "" 
{MPLTEXT 1 257 68 "mult_tbas:=proc(base1::list,base2::list)\n[op(base1
),op(base2)]\nend: " }}}{PARA 256 "" 0 "" {TEXT 256 74 "The parity of \+
a basis element in the tensor algebra is defined as follows." }}
{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 1 257 115 "parity_tbas:=proc(tbas:
:list)\nif tbas=ONE then \nreturn(0)\nfi;\nadd(parity_elem(tbas[i]),i=
1..nops(tbas)) mod 2;\nend:" }}}{PARA 260 "" 0 "" {TEXT 260 0 "" }}}
{SECT 0 {PARA 263 "" 0 "" {TEXT 263 30 "Simple Coefficient Procedures \+
" }}{PARA 256 "" 0 "" {TEXT 256 37 "This is the zero and one coefficie
nt." }}{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 1 257 24 "ZEROCOEF:=0:\nONE
COEF:=1:" }}}{PARA 256 "" 0 "" {TEXT 256 36 "The command below adds co
efficients." }}{EXCHG {PARA 264 "> " 0 "" {MPLTEXT 1 264 29 "add_coef:
=proc(a,b)\na+b;\nend:" }}}{PARA 256 "" 0 "" {TEXT 256 42 "The command
 below mulitplies coefficients." }}{EXCHG {PARA 264 "> " 0 "" 
{MPLTEXT 1 264 30 "mult_coef:=proc(a,b)\na*b;\nend:" }}}{PARA 256 "" 
0 "" {TEXT 256 33 "Convert a number to a coefficient" }}{EXCHG {PARA 
257 "> " 0 "" {MPLTEXT 1 257 50 "mk_num_coef:=proc(a)\nmult_coef_num(O
NECOEF,a)\nend:" }}}{PARA 265 "" 0 "" {TEXT 265 46 "A simple rule for \+
the parity of a coefficient." }}{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 1 
257 28 "parity_coef:=proc(c)\n0;\nend:" }}}{PARA 256 "" 0 "" {TEXT 
256 59 "A simple way to multipy a coefficient by an ordinary number" }
}{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 1 257 45 "mult_coef_num:=proc(coe
f,num) \ncoef*num \nend:" }}}{PARA 256 "" 0 "" {TEXT 256 36 "The way t
o print normal coefficients" }}{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 1 
257 25 "pnt_coef:=proc(a)\na;\nend:" }}}{PARA 256 "" 0 "" {TEXT 256 
55 "Multiply a tensor monomial on the left by a coefficient" }}{EXCHG 
{PARA 257 "> " 0 "" {MPLTEXT 1 257 190 "lmult_tmon_coef:=proc(coef,tmo
n)\nlocal c;\nc:=sgn(parity_coef(coef)*parity_tbase(tmon[TMON_BASE]));
\nc:=mult_coef_num(coef,c);\nc:=mult_coef(c,tmon[TMON_COEF]);\nmk_tmon
(tmon[TMON_BASE],c);\nend:" }}}{PARA 256 "" 0 "" {TEXT 256 45 "Multply
 a tensor on the left by a coefficient" }}{EXCHG {PARA 257 "> " 0 "" 
{MPLTEXT 1 257 211 "lmult_tens_coef:=proc(coef,tens)\nlocal i,res;\nif
 tens=ZEROTENS then \nreturn(ZEROTENS)\nfi;\nres:=ZEROTENS;\nfor i to \+
nops(tens) do\nres:=add_tens(res,mk_tens(lmult_tmon_coef(coef,tens[i])
));\nod;\ncomb_tens(res);\nend:" }}}{PARA 256 "" 0 "" {TEXT 256 56 "Mu
ltiply a tensor monomial on the right by a coefficient" }}{EXCHG 
{PARA 257 "> " 0 "" {MPLTEXT 1 257 95 "rmult_tmon_coef:=proc(tmon,coef
)\nmk_tmon(tmon[TMON_BASE],mult_coef(tmon[TMON_COEF],coef));\nend:" }}
}{PARA 256 "" 0 "" {TEXT 256 47 "Multiply a tensor on the right by a c
oefficient" }}{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 1 257 211 "rmult_ten
s_coef:=proc(tens,coef)\nlocal i,res;\nif tens=ZEROTENS then \nreturn(
ZEROTENS)\nfi;\nres:=ZEROTENS;\nfor i to nops(tens) do\nres:=add_tens(
res,mk_tens(rmult_tmon_coef(tens[i],coef)));\nod;\ncomb_tens(res);\nen
d:" }}}{PARA 256 "" 0 "" {TEXT 256 29 "Multiply a tensor by a number" 
}}{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 1 257 74 "mult_tens_num:=proc(nu
m,tens)\nrmult_tens_coef(tens,mk_num_coef(num));\nend:" }}}{PARA 260 "
" 0 "" {TEXT 260 0 "" }}}{SECT 0 {PARA 263 "" 0 "" {TEXT 263 16 "Tenso
r Monomials" }}{PARA 265 "" 0 "" {TEXT 265 89 "The command below desig
nates the position of the coefficient and the base in a monomial. " }}
{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 1 257 27 "TMON_BASE:=1:\nTMON_COEF
:=2:" }}}{PARA 256 "" 0 "" {TEXT 256 45 "The one and zero monomials ar
e defined below." }}{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 1 257 49 "ONET
MON:=[ONE,ONECOEF]:\nZEROTMON:=[ONE,ZEROCOEF]:" }}}{PARA 256 "" 0 "" 
{TEXT 256 71 "The command below constructs a monomial from a base and \+
a coefficient. " }}{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 1 257 193 "mk_t
mon:=proc(base::list)\nlocal coef,c;\ncoef:=ONECOEF; \nif nargs>1 then
 \ncoef:=args[2]\nfi;\nif coef<>ZEROCOEF then\nc[TMON_BASE]:=base:\nc[
TMON_COEF]:=coef:\nreturn([c[1],c[2]]):\nfi;\nZEROTMON;\nend:" }}}
{PARA 256 "" 0 "" {TEXT 256 43 "The parity of a monomial is computed b
elow." }}{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 1 257 93 "parity_tmon:=pr
oc(tmon)\nparity_tbas(tmon[TMON_BASE])+parity_coef(tmon[TMON_COEF]) mo
d 2;\nend:" }}}{PARA 256 "" 0 "" {TEXT 256 62 "This program computes t
he exterior degree of a tensor monomial" }}{EXCHG {PARA 257 "> " 0 "" 
{MPLTEXT 1 257 50 "degree_tmon:=proc(tmon)\nnops(tmon[TMON_BASE])\nend
:" }}}{PARA 260 "" 0 "" {TEXT 260 0 "" }}}{SECT 0 {PARA 263 "" 0 "" 
{TEXT 263 7 "Tensors" }}{PARA 256 "" 0 "" {TEXT 256 43 "The one and ze
ro tensors are defined below." }}{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 
1 257 33 "ZEROTENS:=[]:\nONETENS:=[ONETMON]:" }}}{PARA 256 "" 0 "" 
{TEXT 256 51 "The command below makes a tensor out of a monomial." }}
{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 1 257 75 "mk_tens:=proc(tmon)\nif \+
tmon=ZEROTMON then \nreturn(ZEROTENS)\nfi;\n[tmon]\nend:" }}}{PARA 
256 "" 0 "" {TEXT 256 44 "The command below adds two tensors together.
" }}{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 1 257 74 "add_tens:=proc(tenso
r1::list,tensor2::list)\n[op(tensor1),op(tensor2)]\nend:" }}}{PARA 
256 "" 0 "" {TEXT 256 66 "The command below simplifies a tensor by com
bining its like terms." }}{EXCHG {PARA 266 "> " 0 "" {MPLTEXT 1 266 
579 "comb_tens:=proc(tensor::list)\nlocal final,rest,i,coef,base;\nif \+
tensor=ZEROTENS then \nreturn ZEROTENS \nfi;\nrest:=ZEROTENS;\ncoef:=t
ensor[1][TMON_COEF];\nbase:=tensor[1][TMON_BASE];\nfor i from 2 to nop
s(tensor) do\nif tensor[i][TMON_BASE]=base then\ncoef:=add_coef(coef,t
ensor[i][TMON_COEF])\nelse\nrest:=add_tens(rest,mk_tens(tensor[i]))\nf
i;\nod;\nif coef<> ZEROCOEF\nthen\nif rest<>ZEROTENS\nthen\nfinal:=add
_tens(mk_tens(mk_tmon(base,coef)),comb_tens(rest));\nelse\nfinal:=mk_t
ens(mk_tmon(base,coef));\nfi;\nelse\nif rest<>ZEROTENS\nthen\nfinal:=c
omb_tens(rest);\nelse\nfinal:=ZEROTENS;\nfi;\nfi;\nend:" }}}{PARA 256 
"" 0 "" {TEXT 256 50 "The command below multiplies two tensors togethe
r." }}{EXCHG {PARA 266 "> " 0 "" {MPLTEXT 1 266 401 "mult_tens:=proc(t
ens1,tens2)\nlocal i,j,coef,final;\nfinal:=ZEROTENS;\nfor i to nops(te
ns1) do\nfor j to nops(tens2) do\ncoef:=(-1)^(parity_coef(tens1[i][TMO
N_COEF])*parity_tbas(tens2[j][TMON_BASE]));\ncoef:=mult_coef_num(mult_
coef(tens1[i][TMON_COEF],tens2[j][TMON_COEF]),coef);\nfinal:=add_tens(
final,mk_tens(mk_tmon(mult_tbas(tens1[i][TMON_BASE],tens2[j][TMON_BASE
]),coef)));\nod;od;\ncomb_tens(final);\nend:" }}}{PARA 256 "" 0 "" 
{TEXT 256 115 "This routine gives the part of a tensor consisting of a
ll monomials of degree less than or equal to a cutoff value." }}
{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 1 257 216 "cutoff_tens:=proc(tens,
cutoff)\nlocal i,res;\nif tens=ZEROTENS then \nreturn ZEROTENS \nfi;\n
res:=ZEROTENS;\nfor i to nops(tens)do\nif degree_tmon(tens[i])<=cutoff
 then \nres:=add_tens(res,mk_tens(tens[i])) fi;\nod;\nres;\nend:" }}}
{PARA 260 "" 0 "" {TEXT 260 0 "" }}}{SECT 0 {PARA 267 "" 0 "" {TEXT 
267 22 "Prettyprinting Tensors" }}{PARA 256 "" 0 "" {TEXT 256 61 "The \+
following prints a tensor basis element in standard form." }}{EXCHG 
{PARA 257 "> " 0 "" {MPLTEXT 1 257 84 "pnt_tbase:=proc(tbas)\nlocal ou
t;\nif tbas=ONE then \nreturn(1)fi;\nout:='e'[tbas];\nend:" }}}{PARA 
260 "" 0 "" {TEXT 260 0 "" }}{PARA 256 "" 0 "" {TEXT 256 56 "The follo
wing prints a tensor monomial in standard form." }}{EXCHG {PARA 257 ">
 " 0 "" {MPLTEXT 1 257 153 "pnt_tmon:=proc(tmon)\nlocal coef,tbas;\nif
  tmon=[] then \nreturn(0);\nfi;\ncoef:=tmon[TMON_COEF];\ntbas:=tmon[T
MON_BASE];\npnt_tbase(tbas)*pnt_coef(coef);\nend:" }}}{PARA 256 "" 0 "
" {TEXT 256 69 "The following prints a tensor as a sum of monomials in
 standard form." }}{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 1 257 110 "pnt_
tens:=proc(tens)\nlocal i;\nif tens=ZEROTENS then \nreturn(0)fi;\nadd(
pnt_tmon(tens[i]),i=1..nops(tens));\nend:" }}}{PARA 260 "" 0 "" {TEXT 
260 0 "" }}}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{SECT 0 
{PARA 269 "" 0 "" {TEXT 269 17 "Coderivation Code" }}{PARA 258 "" 0 "
" {TEXT 258 0 "" }}{SECT 0 {PARA 270 "" 0 "" {TEXT 270 12 "Coefficient
s" }}{PARA 256 "" 0 "" {TEXT 256 39 "Modify the routines here as appro
priate" }}{PARA 256 "" 0 "" {TEXT 256 59 "The following program gives \+
the parity of our coefficients." }}{EXCHG {PARA 257 "> " 0 "" 
{MPLTEXT 1 257 27 "parity_coef:=proc()\n0;\nend:" }}}{PARA 256 "" 0 "
" {TEXT 256 69 "Multiplication of coderivation monomials on the left b
y a coefficient" }}{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 1 257 224 "lmul
t_cmon_coef:=proc(a,L)\nlocal res,cbas,ccoef,par,coef;\ncbas:=L[CMON_B
ASE];\nccoef:=L[CMON_COEF];\npar:=(-1)^(parity_cbase(cbas)*parity_coef
(ccoef));\ncoef:=mult_coef(mult_coef_num(a,par),ccoef);\nres:=mk_cmon(
cbas,coef);\nend:" }}}{PARA 256 "" 0 "" {TEXT 256 71 "Multiplication o
f coderivation monomials on the right by a coefficient." }}{EXCHG 
{PARA 257 "> " 0 "" {MPLTEXT 1 257 154 "rmult_cmon_coef:=proc(L,a)\nlo
cal res,cbas,ccoef,par,coef;\ncbas:=L[CMON_BASE];\nccoef:=L[CMON_COEF]
;\ncoef:=mult_coef(ccoef,a);\nres:=mk_cmon(cbas,coef);\nend:" }}}
{PARA 256 "" 0 "" {TEXT 256 52 "Multiplication of coderivation monomia
ls by a number" }}{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 1 257 108 "mult_
cmon_num:=proc(n,cmon)\nlocal res,coef;\ncoef:=mult_coef_num(ONECOEF,n
);\nlmult_cmon_coef(coef,cmon);\nend:" }}}{PARA 256 "" 0 "" {TEXT 256 
62 "Left multiplication of a general coderivation by a coefficient" }}
{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 1 257 170 "lmult_coder_coef:=proc(
a,coder)\nlocal i, res, mon;\nres:=ZEROCODER;\nfor i to nops(coder) do
\nmon:=lmult_cmon_coef(a,coder[i]);\nres:=[op(res),mon];\nod;\ncomb_co
der(res);\nend:" }}}{PARA 256 "" 0 "" {TEXT 256 63 "Right multiplicati
on of a general coderivation by a coefficient" }}{EXCHG {PARA 257 "> \+
" 0 "" {MPLTEXT 1 257 170 "rmult_coder_coef:=proc(coder,a)\nlocal i, r
es, mon;\nres:=ZEROCODER;\nfor i to nops(coder) do\nmon:=rmult_cmon_co
ef(coder[i],a);\nres:=[op(res),mon];\nod;\ncomb_coder(res);\nend:" }}}
{PARA 256 "" 0 "" {TEXT 256 52 "Multiplication of a general coderivati
on by a number" }}{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 1 257 112 "mult_
coder_num:=proc(n,coder)\nlocal res,coef;\ncoef:=mult_coef_num(ONECOEF
,n);\nlmult_coder_coef(coef,coder);\nend:" }}}{PARA 256 "" 0 "" {TEXT 
256 22 "Printing a coefficient" }}{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 
1 257 23 "pnt_coef:=proc(c)c;end:" }}}{PARA 258 "" 0 "" {TEXT 258 0 "
" }}}{SECT 0 {PARA 270 "" 0 "" {TEXT 270 18 "Coderivation Bases" }}
{PARA 256 "" 0 "" {TEXT 256 74 "We designate the positions of the list
 and index in the coderivation base." }}{EXCHG {PARA 257 "> " 0 "" 
{MPLTEXT 1 257 30 "CBASE_LIST:=1:\nCBASE_INDEX:=2:" }}}{PARA 256 "" 0 
"" {TEXT 256 59 "The command below makes a cbase out of a list and an \+
index." }}{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 1 257 117 "mk_cbase:=pro
c(List,index)\nlocal out, res;\nres[CBASE_LIST]:=List;\nres[CBASE_INDE
X]:=index;\nout:=[res[1],res[2]];\nend:" }}}{PARA 256 "" 0 "" {TEXT 
256 57 "The program below find the parity of a coderivation base." }}
{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 1 257 134 "parity_cbase:=proc(cbas
::[list,posint])  \nlocal i,par;\npar:=(parity_elem(cbas[CBASE_INDEX])
+parity_tbas(cbas[CBASE_LIST])) mod 2;\nend:" }}}{PARA 256 "" 0 "" 
{TEXT 256 63 "The program below applies a coderivation base to a tenso
r base." }}{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 1 257 455 "apply_cbase_
tbas:=proc(cbas::[list,posint],tbas::list)\nlocal res,j,J,k,coef,derte
rm,otbas,derlist;\nres:=ZEROTENS;\nJ:=cbas[CBASE_LIST];\nj:=cbas[CBASE
_INDEX];\nif tbas=ONE then \nreturn(ZEROTENS)\nfi;\nfor k from 0 to no
ps(tbas)-nops(J) do\ncoef:=deltaij(J,tbas[k+1..k+nops(J)])*sgn(parity_
tbas(tbas[1..k])*parity_cbase(cbas));\notbas:=[op(tbas[1..k]),j,op(tba
s[k+nops(J)+1..nops(tbas)])];\nres:=add_tens(res,mk_tens(mk_tmon(otbas
,coef)));\nod;\ncomb_tens(res);\nend:" }}}{PARA 256 "" 0 "" {TEXT 256 
67 "The program below applies a coderivation base to a tensor monomial
." }}{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 1 257 171 "apply_cbase_tmon:=
proc(cbas,tmon)\nlocal res,coef,tbas;\ntbas:=tmon[TMON_BASE];\ncoef:=t
mon[TMON_COEF];\nres:=apply_cbase_tbas(cbas,tbas);\nres:=rmult_tens_co
ef(res,coef);\nend:" }}}{PARA 258 "" 0 "" {TEXT 258 58 "This next prog
ram applies a coderivation base to a tensor." }}{EXCHG {PARA 259 "> " 
0 "" {MPLTEXT 1 259 162 "apply_cbase_tens:=proc(cbas,tens)\nlocal res,
tmon;\nres:=ZEROTENS;\nfor tmon in tens do\nres:=add_tens(res,apply_cb
ase_tmon(cbas,tmon));\nod;\nres:=comb_tens(res);\nend:" }}}{PARA 258 "
" 0 "" {TEXT 258 0 "" }}}{SECT 0 {PARA 270 "" 0 "" {TEXT 270 22 "Coder
ivation Monomials" }}{PARA 256 "" 0 "" {TEXT 256 79 "We designate posi
tions for the base and coeficient in the coderivation monomial" }}
{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 1 257 27 "CMON_BASE:=1:\nCMON_COEF
:=2:" }}}{PARA 256 "" 0 "" {TEXT 256 76 "The command below makes coder
ivation monomails from a base and a coeficient." }}{EXCHG {PARA 257 ">
 " 0 "" {MPLTEXT 1 257 149 "mk_cmon:=proc(cbas)\nlocal res,coef;\nres[
CMON_BASE]:=cbas:\ncoef:=ONECOEF;\nif nargs>1 then coef:=args[2]fi;\nr
es[CMON_COEF]:=coef;\n[res[1],res[2]];\nend:" }}}{PARA 256 "" 0 "" 
{TEXT 256 62 "The program below finds the parity of a coderivation mon
omial." }}{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 1 257 95 "parity_cmon:=p
roc(cmon) \nparity_cbase(cmon[CMON_BASE])+parity_coef(cmon[CMON_COEF])
 mod 2;\nend:" }}}{PARA 256 "" 0 "" {TEXT 256 62 "The program below ap
plies a coderivation monomial to a tensor." }}{EXCHG {PARA 257 "> " 0 
"" {MPLTEXT 1 257 195 "apply_cmon_tens:=proc(cmon,tens)\nlocal cbas,co
ef,res,ntens;\nres:=ZEROTENS;\ncbas:=cmon[CMON_BASE];\ncoef:=cmon[CMON
_COEF];\nntens:=lmult_tens_coef(coef,tens);\nres:=apply_cbase_tens(cba
s,ntens);\nend:" }}}{PARA 258 "" 0 "" {TEXT 258 0 "" }}}{SECT 0 {PARA 
270 "" 0 "" {TEXT 270 13 "Coderivations" }}{PARA 256 "" 0 "" {TEXT 
256 22 "The zero coderivation." }}{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 
1 257 14 "ZEROCODER:=[]:" }}}{PARA 256 "" 0 "" {TEXT 256 68 "The comma
nd below makes a coderivation from a coderivation monomial." }}{EXCHG 
{PARA 257 "> " 0 "" {MPLTEXT 1 257 32 "mk_coder:=proc(cmon)\n[cmon]\ne
nd:" }}}{PARA 256 "" 0 "" {TEXT 256 48 "The command below adds two der
ivations together." }}{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 1 257 59 "ad
d_coder:=proc(coder1,coder2)\n[op(coder1),op(coder2)]\nend:" }}}{PARA 
258 "" 0 "" {TEXT 258 77 "The command below determines the parity, if \+
well defined,  of a coderivation." }}{EXCHG {PARA 259 "> " 0 "" 
{MPLTEXT 1 259 242 "parity_coder:=proc(cder::list)\nlocal i,p;\nif cde
r=ZEROCODER then \nreturn(0) \nfi;\np:=parity_cmon(cder[1]);\nfor i fr
om 2 to nops(cder) do\nif parity_cmon(cder[i])<>p then \nERROR(\"Parit
y of this coderivation is not well defined\");\nfi\nod; \np;\nend:" }}
}{PARA 256 "" 0 "" {TEXT 256 72 "The command below simplifies a coderi
vation by combining its like terms." }}{EXCHG {PARA 257 "> " 0 "" 
{MPLTEXT 1 257 579 "comb_coder:=proc(coder)\nlocal final,rest,i,coef,b
ase;\nif coder=ZEROCODER then \nreturn ZEROCODER \nfi;\nrest:=ZEROCODE
R;\ncoef:=coder[1][CMON_COEF];\nbase:=coder[1][CMON_BASE];\nfor i from
 2 to nops(coder) do\nif coder[i][CMON_BASE]=base then\ncoef:=add_coef
(coef,coder[i][CMON_COEF])\nelse\nrest:=add_coder(rest,mk_coder(coder[
i]))\nfi;\nod;\nif coef<> ZEROCOEF\nthen\nif rest<>ZEROCODER\nthen\nfi
nal:=add_coder(mk_coder(mk_cmon(base,coef)),comb_coder(rest));\nelse\n
final:=mk_coder(mk_cmon(base,coef));\nfi;\nelse\nif rest<>ZEROCODER\nt
hen\nfinal:=comb_coder(rest);\nelse\nfinal:=ZEROCODER;\nfi;\nfi;\nend:
" }}}{PARA 258 "" 0 "" {TEXT 258 67 "The command below will add and si
mplify a sequence of coderivations" }}{EXCHG {PARA 259 "> " 0 "" 
{MPLTEXT 1 259 157 "ad:=proc()\nlocal i,out;\nout:=ZEROCODER;\nout:=[s
eq(op(args[i]),i=1..nargs)];\n#for i from 1 to nargs do \n#out:=[op(ou
t),op(args[i])]\n#od;\ncomb_coder(out);\nend:" }}}{PARA 256 "" 0 "" 
{TEXT 256 57 "The following program applies a coderivation to a tensor
." }}{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 1 257 242 "apply_coder_tens:=
proc(coder,tens)\nlocal res,i;\n#res:=ZEROTENS;\nres:=[seq(op(apply_cm
on_tens(coder[i],tens)),i=1..nops(coder))];\n#for i from 1 to nops(cod
er) do\n#res:=[op(res),op(apply_cmon_tens(coder[i],tens))]\n#od;\nres:
=comb_tens(res);\nend:" }}}{PARA 258 "" 0 "" {TEXT 258 0 "" }}}{SECT 
0 {PARA 270 "" 0 "" {TEXT 270 25 "Brackets of Coderivations" }}{PARA 
256 "" 0 "" {TEXT 256 63 "This routine computes the composition of two
 coderivation bases" }}{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 1 257 319 "
comp_cbase:=proc(cbas1,cbas2)\nlocal out,J,j,K,k;\nJ:=cbas1[CBASE_LIST
];\nj:=cbas1[CBASE_INDEX];\nK:=cbas2[CBASE_LIST];\nk:=cbas2[CBASE_INDE
X];\nout:=[seq(mk_cmon([[op(J[1..i-1]),op(K),op(J[i+1..nops(J)])],j],m
k_num_coef(deltaij(J[i],k)*sgn(parity_tbas(J[1..i-1])*parity_cbase(cba
s2))\n)),i=1..nops(J))];\ncomb_coder(out);\nend:" }}}{PARA 256 "" 0 "
" {TEXT 256 73 "The routine below computes the composition of two code
rivation monomials." }}{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 1 257 351 "
comp_cmon:=proc(cmon1,cmon2)\nlocal cbas1,cbas2,coef1,coef2,num,coef,r
es;\ncbas1:=cmon1[CMON_BASE];\ncbas2:=cmon2[CMON_BASE];\ncoef1:=cmon1[
CMON_COEF];\ncoef2:=cmon2[CMON_COEF];\nnum:=sgn(parity_coef(coef1)*par
ity_cbase(cbas2));\ncoef:=mult_coef(coef1,coef2);\ncoef:=mult_coef_num
(coef,num);\nres:=comp_cbase(cbas1,cbas2);\nres:=rmult_coder_coef(res,
coef);\nend:" }}}{PARA 256 "" 0 "" {TEXT 256 62 "The routine below com
putes the composition of two derivations." }}{EXCHG {PARA 257 "> " 0 "
" {MPLTEXT 1 257 194 "comp_coder:=proc(coder1,coder2)\nlocal i,j, res;
\nres:=ZEROCODER;\nfor i to nops(coder1) do\nfor j to nops(coder2) do
\nres:=add_coder(res,comp_cmon(coder1[i],coder2[j]));\nod;od;\ncomb_co
der(res);\nend:" }}}{PARA 256 "" 0 "" {TEXT 256 64 "The routine below \+
computes the bracket of two coderivation bases" }}{EXCHG {PARA 257 "> \+
" 0 "" {MPLTEXT 1 257 230 "brack_cbase:=proc(cbas1,cbas2)\nlocal res1,
res2,num,coef;\nres1:=comp_cbase(cbas1,cbas2);\nres2:=comp_cbase(cbas2
,cbas1);\nnum:=sgn(parity_cbase(cbas1)*parity_cbase(cbas2)+1);\ncomb_c
oder(add_coder(res1,mult_coder_num(num,res2)));\nend:" }}}{PARA 256 "
" 0 "" {TEXT 256 69 "The routine below computes the bracket of two cod
erivation monomials." }}{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 1 257 225 
"brack_cmon:=proc(cmon1,cmon2)\nlocal res1,res2,num,coef;\nres1:=comp_
cmon(cmon1,cmon2);\nres2:=comp_cmon(cmon2,cmon1);\nnum:=sgn(parity_cmo
n(cmon1)*parity_cmon(cmon2)+1);\ncomb_coder(add_coder(res1,mult_coder_
num(num,res2)));\nend:" }}}{PARA 256 "" 0 "" {TEXT 256 65 "The routine
 below computes the bracket of two general derivations" }}{EXCHG 
{PARA 257 "> " 0 "" {MPLTEXT 1 257 196 "brack_coder:=proc(coder1,coder
2)\nlocal i,j, res;\nres:=ZEROCODER;\nfor i to nops(coder1) do\nfor j \+
to nops(coder2) do\nres:=add_coder(res,brack_cmon(coder1[i],coder2[j])
);\nod;od;\ncomb_coder(res);\nend:" }}}{PARA 258 "" 0 "" {TEXT 258 0 "
" }}}{SECT 0 {PARA 270 "" 0 "" {TEXT 270 12 "Exponentials" }}{PARA 
268 "" 0 "" {TEXT 268 0 "" }}{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 1 
257 104 "adm:= proc(mu,delta,m::nonnegint)\nif m=0 then \nreturn(delta
) \nfi;\nbrack_coder(mu,adm(mu,delta,m-1))\nend:" }}}{PARA 256 "" 0 "
" {TEXT 256 24 "The function   e^(-adm)." }}{EXCHG {PARA 257 "> " 0 "
" {MPLTEXT 1 257 192 "expm:=proc(mu,delta,m::nonnegint)\nlocal i,out,r
es;\nres:=delta;\nfor i from 1 to m do\nout:=adm(mu,delta,i);\nout:=mu
lt_coder_num((-1)^i/i!,out);\nres:=add_coder(res,out);\nod;\ncomb_code
r(res);\nend:" }}}{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 1 257 121 "power
_coder:=proc(mu,tens,n::nonnegint)\nif n=0 then \nreturn(tens)\nfi;\na
pply_coder_tens(mu,power_coder(mu,tens,n-1));\nend:" }}}{EXCHG {PARA 
257 "> " 0 "" {MPLTEXT 1 257 200 "exp_coder:=proc(mu,tens,m::nonnegint
)\nlocal i,term, res;\nres:=tens;\nfor i from 1 to m do\nterm:=power_c
oder(mu,tens,i);\nterm:=mult_tens_num(1/i!,term);\nres:=add_tens(res,t
erm);\nod;\ncomb_tens(res);\nend:" }}}{PARA 258 "" 0 "" {TEXT 258 0 "
" }}}{SECT 0 {PARA 270 "" 0 "" {TEXT 270 28 "Prettyprinting Coderivati
ons" }}{PARA 256 "" 0 "" {TEXT 256 67 "The following prints a coderiva
tion basis element in standard form." }}{EXCHG {PARA 257 "> " 0 "" 
{MPLTEXT 1 257 198 "pnt_cbase:=proc(cbas)\nlocal out,thelist,theindex;
\nthelist:=cbas[CBASE_LIST];\ntheindex:=cbas[CBASE_INDEX];\nif parity_
cbase(cbas)=0 then\n'phi'[theindex]^thelist;\nelse\n'psi'[theindex]^th
elist;\nfi;\nend:" }}}{PARA 268 "" 0 "" {TEXT 268 0 "" }}{PARA 256 "" 
0 "" {TEXT 256 62 "The following prints a coderivation monomial in sta
ndard form." }}{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 1 257 120 "pnt_cmon
:=proc(cmon)\nlocal coef,cbas;\ncoef:=cmon[CMON_COEF];\ncbas:=cmon[CMO
N_BASE];\npnt_cbase(cbas)*pnt_coef(coef);\nend:" }}}{PARA 256 "" 0 "" 
{TEXT 256 75 "The following prints a coderivation as a sum of monomial
s in standard form." }}{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 1 257 117 "
pnt_coder:=proc(coder)\nlocal i;\nif coder=ZEROCODER then \nreturn(0)
\nfi;\nadd(pnt_cmon(coder[i]),i=1..nops(coder));\nend:" }}}{PARA 256 "
" 0 "" {TEXT 256 62 "This routine shows how the coderivation is applie
d to a tensor" }}{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 1 257 137 "showde
r:=proc(coder,tens)\nlocal res;\nres:=apply_coder_tens(coder,tens);\np
rint((pnt_coder(coder)*pnt_tens(tens))=pnt_tens(res));\nres;\nend:" }}
}{PARA 258 "" 0 "" {TEXT 258 0 "" }}}{SECT 0 {PARA 270 "" 0 "" {TEXT 
270 22 "User Freindly Routines" }}{PARA 258 "" 0 "" {TEXT 258 98 "The \+
following routine allows the construction of a coderivation from a bas
e, an index and a number" }}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 
160 "mph:=proc(J,j,c)\nlocal cbas,cmon,coder,coef;\ncoef:=1;\nif nargs
 = 3 then \ncoef:=c \nfi;\ncbas:=mk_cbase(J,j);\ncmon:=mk_cmon(cbas,co
ef);\ncoder:=mk_coder(cmon);\nend:" }}}{PARA 258 "" 0 "" {TEXT 258 78 
"The following routine multiplies a coderivation on the right by a coe
fficient." }}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 51 "mc:=proc(cd
er,coef)rmult_coder_coef(cder,coef):end:" }}}{PARA 258 "" 0 "" {TEXT 
258 60 "The following routine prints a coderivation in readable form" 
}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 36 "pc:=proc(L)\nprint(pnt
_coder(L))\nend:" }}}{PARA 258 "" 0 "" {TEXT 258 78 "The following rou
tine computes a bracket of two coderivations in readable form" }}
{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 23 "pb:=proc(coder1,coder2)
" }}{PARA 259 "> " 0 "" {MPLTEXT 1 259 83 "print([pnt_coder(coder1),pn
t_coder(coder2)]=pnt_coder(brack_coder(coder1,coder2))):" }}{PARA 259 
"> " 0 "" {MPLTEXT 1 259 4 "end:" }}}{PARA 258 "" 0 "" {TEXT 258 62 "T
he following is a short hand version of the bracket operation" }}
{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 51 "tb:=proc(cder1,cder2)\nb
rack_coder(cder1,cder2)\nend:" }}}{PARA 258 "" 0 "" {TEXT 258 90 "The \+
following prints the bracket of two coderivations, without printing th
e coderivations." }}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 82 "sb:=
proc(cder1,cder2)\nlocal res;\nres:=brack_coder(cder1,cder2);\npc(res)
;\nres;\nend:" }}}{PARA 258 "" 0 "" {TEXT 258 96 "The following routin
e adds a sequence of coderivations and prints the result in a readable
 form." }}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 138 "pad:=proc()\n
local i,out;\nout:=ZEROCODER;\nfor i from 1 to nargs do \nout:=[op(out
),op(args[i])]\nod;\nout:=comb_coder(out);\npc(out);\nout;\nend:" }}}
{PARA 258 "" 0 "" {TEXT 258 0 "" }}}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}}{SECT 0 {PARA 269 "" 0 "" {TEXT 269 16 " A-infini
ty Code" }}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 20 "with(LinearAl
gebra):" }}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 31 "interface(rt
ablesize=infinity):" }}}{EXCHG {PARA 271 "" 0 "" {TEXT 271 87 "BC make
s a list of length N with l one's and the rest zeros. Returns the nth \+
such list." }}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 356 "BC:=proc
(n::posint,N::posint,l::nonnegint)\nlocal i,k,x,h,res,out;\nif n>binom
ial(N,l) then \nERROR(\"n exceeds the maximum\") \nfi;\nif l=0 then \n
return([seq(0,i=1..N)]);\nelif \nl=1 then \nreturn([seq(0,i=1..n-1),1,
seq(0,i=n+1..N)])\nfi;\nx:=0;\nh:=binomial(x+l-l,l);\nwhile h < n do\n
k:=n-h;\nx:=x+1;\nh:=binomial(x+l-1,l);\nod;\nres:=BC(k,N,l-1);\nres[x
+l-1]:=1;\nres:\nend:" }}}{EXCHG {PARA 271 "" 0 "" {TEXT 271 65 "RC re
turns a list of the positions of one's in the original list." }}}
{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 124 "RC:=proc(lst::list)\nlo
cal i,out;\nout:=[];\nfor i from 1 to nops(lst) do \nif lst[i]=1 then \+
\nout:=[op(out),i] \nfi;od;\nout;\nend:" }}}{EXCHG {PARA 271 "" 0 "" 
{TEXT 271 57 "AC returns the nth basis element of a tensor of degree k
." }}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 718 "AC:=proc(n::posin
t,k::nonnegint)\nlocal i,j,r,s,t,u,m,res,bn,out;\nif k=0 \nthen \nif n
>1 then \nERROR(\"n is too large\") \nfi;\nreturn([])\nfi;\nif k=1 the
n \nreturn([n])\nfi;\nm:=0;\nwhile true do\nif (m+1)^k<n then \nm:=m+1
;\nnext; \nfi;\nbreak;\nod;\nr:=0;\nwhile true do \nif n>add(binomial(
k,l)*m^(k-l),l=0..r+1) then \nr:=r+1;\nnext;\nfi;break;od;\ns:=n-add(b
inomial(k,l)*m^(k-l),l=0..r);\nt:=0;\nwhile true do \nif (t+1)*m^(k-r-
1)<s then \nt:=t+1;\nnext;fi;\nbreak;od;\nu:=s-t*m^(k-r-1);\nres:=AC(u
,k-r-1);\n#print([m,r,s,t,u],[u,k-r-1],[t,k,r+1],res);\nbn:=BC(t+1,k,k
-r-1);\nout:=[seq(0,i=1..k)];\n#print([m,r,s,t,u],[u,k-r-1],res,bn);\n
i:=1;\nfor j from 1 to k do \nif bn[j]=0 then \nout[j]:=m+1 \nelse\nou
t[j]:=res[i];\ni:=i+1;\nfi od;\nreturn(out);\nend:\n" }}}{EXCHG {PARA 
271 "" 0 "" {TEXT 271 133 "BC_inv takes a list that tells which spaces
 are nonzero spaces of the tensor algebra and gives the number it is i
n our ordered basis." }}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 
238 "BC_inv:=proc(L)\nlocal l,n,N,K,M,i,j;\nl:=add(L[i],i=1..nops(L));
\nn:=0;\nif l=0 then \nreturn(1)\nfi;\nN:=nops(L);\nK:=L;\nfor i from \+
0 to N-1 do\nif L[N-i]=0 then \nnext \nfi; \nK[N-i]:=K[N-i]-1;\nn:=bin
omial(N-i-1,l);\nbreak;\nod;\nn:=n+BC_inv(K);\nend:" }}}{EXCHG {PARA 
271 "" 0 "" {TEXT 271 123 "AC_inv takes a list that represents a basis
 vector in the tensor algebra and returns the number it is in our orde
red basis." }}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 434 "AC_inv:=
proc(L::list)\nlocal i,k,l,m,r,s,t,u,n,res,bc;\nk:=nops(L);\nif k=0 th
en \nreturn(1)\nfi;\nm:=L[1]-1;\nr:=0;\nfor i from 2 to k do \nif L[i]
=m+1 then \nr:=r+1; \nelif L[i]>m then\nm:=L[i]-1;\nr:=0;\nfi; \nod;\n
bc:=[seq(1,i=1..k)];\nres:=[];\nfor i to k do \nif L[i]=m+1 then \nbc[
i]:=0 \nelse \nres:=[op(res),L[i]]\nfi;od;\nu:=AC_inv(res);\nt:=BC_inv
(bc)-1;\ns:=u+t*m^(k-r-1);\n#print([m,k,r,s,u,t,res,bc]);\nn:=s+add(bi
nomial(k,l)*m^(k-l),l=0..r);\nend:\n" }}}{EXCHG {PARA 0 "" 0 "" {TEXT 
258 64 "The procedure num_chn computes the number of  chains of degree
 l" }{TEXT -1 0 "" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 45 "num_ch
n:=proc(l::nonnegint)\nDIMENSION^l;\nend:" }}}{EXCHG {PARA 258 "" 0 "
" {TEXT 258 63 "The procedure mk_cochn calculates the n-th cochain of \+
degree l." }}{PARA 259 "> " 0 "" {MPLTEXT 1 259 152 "mk_cochn:=proc(n:
:posint,l::nonnegint)\nlocal out, Q,R,N;\nQ:=iquo(n,DIMENSION,'R');\ni
f R=0 then \nQ:=Q-1;\nR:=DIMENSION \nfi;\nQ:=Q+1;\nout:=[AC(Q,l),R];\n
end:" }}}{EXCHG {PARA 258 "" 0 "" {TEXT 258 61 "The procedure mk_cochn
s calculates all cochains of degree l. " }}{PARA 259 "> " 0 "" 
{MPLTEXT 1 259 134 "mk_cochns:=proc(l::nonnegint)\nlocal i,out;\nout:=
[]:\nfor i from 1 to num_chn(l)*DIMENSION do\nout:=[op(out),mk_cochn(i
,l)]\nod;\nout;\nend:" }}}{EXCHG {PARA 258 "" 0 "" {TEXT 258 70 "The p
rocedure cochn_inv computes the number n for an arbitrary cochain" }}
{PARA 258 "" 0 "" {TEXT 258 39 "L of degree l such that mk_cochn(n,l)=
L" }}{PARA 259 "> " 0 "" {MPLTEXT 1 259 96 "cochn_inv:=proc(L)\nlocal \+
K,R,Q,n;\nR:=L[2]:\nK:=L[1]:\nQ:=AC_inv(K):\nQ:=Q-1;\nn:=Q*DIMENSION+R
;\nend:" }}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 160 "zmka:=proc(
)\nlocal i,j,l:\nglobal a;\nl:=2:\nif nargs<>0 then \nl:=args[1] \nfi:
\nfor i from 1 to DIMENSION do \nfor j from 1 to num_chn(l) do \na[i,j
]:=0:\nod;\nod;\nend:" }}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 
163 "zmkaa:=proc()\nlocal i,j,l:\nglobal aa;\nl:=2:\nif nargs<>0 then \+
\nl:=args[1] \nfi:\nfor i from 1 to DIMENSION do \nfor j from 1 to num
_chn(l) do \naa[i,j]:=0;\nod;\nod;\nend:" }}}{EXCHG {PARA 259 "> " 0 "
" {MPLTEXT 1 259 115 "zmkg:=proc()\nlocal i,j;\nglobal g;\nfor i from \+
1 to DIMENSION do\nfor j from 1 to DIMENSION do\ng[i,j]:=0:\nod:od:\ne
nd: " }}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 244 "umka:=proc()\n
local i,j,l;\nglobal a;\nl:=2:\nif nargs<>0 then \nl:=args[1] \nfi:\nf
or i from 1 to DIMENSION do \nfor j from 1 to num_chn(l) do \na[i,j]:=
0;\nif parity_tbas(AC(j,l))=parity_elem(i) then\na[i,j]:=0;\nelse \nun
assign('a[i,j]')\nfi;\nod;\nod;\nend:" }}}{EXCHG {PARA 259 "> " 0 "" 
{MPLTEXT 1 259 237 "umkaa:=proc()\nlocal i,j,l:\nglobal aa;\nl:=2:\nif
 nargs<>0 then \nl:=args[1] \nfi:\nfor i from 1 to DIMENSION do \nfor \+
j from 1 to num_chn(l) do \nif parity_tbas(AC(j,l))=parity_elem(i) the
n\naa[i,j]:=0;\nelse \nunassign('aa[i,j]')\nfi;\nod;\nod;\nend:" }}}
{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 242 "umkg:=proc()\nlocal i,j
;\nglobal g;\nfor i from 1 to DIMENSION do\nfor j from 1 to DIMENSION \+
do\ng[i,j]:=0:\nif (parity_elem(i)=EVEN and parity_elem(j)=EVEN) or (p
arity_elem(i)=ODD and parity_elem(j)=ODD) \nthen \nunassign('g[i,j]') \+
\nfi:\nod:od:\nend: " }}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 
109 "mka:=proc()\nlocal l;\nl:=2: \nif nargs<>0 then \nl:=args[1] \nfi
:\nMatrix(DIMENSION,num_chn(l),(i,j)->a[i,j])\nend:" }}}{EXCHG {PARA 
259 "> " 0 "" {MPLTEXT 1 259 110 "mkaa:=proc()\nlocal l;\nl:=2: \nif n
args<>0 then \nl:=args[1] fi:\nMatrix(DIMENSION,num_chn(l),(i,j)->aa[i
,j])\nend:" }}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 68 "mkg:=proc
()\nglobal g;\nMatrix(DIMENSION,DIMENSION,(i,j)->g[i,j])\nend:" }}}
{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 271 "mattoder:=proc(A)\nloca
l res,i,j,k,M,N;\nres:=ZEROCODER;\nN:=ColumnDimension(A):\nk:=log[DIME
NSION](N);\nif not type(k,nonnegint)then error(\"Improper Matrix Size
\")fi;\nM:=RowDimension(A):\nfor i from 1 to M do\nfor j from 1 to N d
o\nres:=ad(res,mph(AC(j,k),i,A[i,j]));\nod;od;\nend:" }}}{EXCHG {PARA 
0 "" 0 "" {TEXT -1 401 "The command typet computes the degree of a ten
sor if it contains monomials of the same degree. It returns an error i
f the tensor is not of homogeneous degree. It doesn't return an error \+
in some cases where the input is not a tensor (MISTAKE). This command \+
is only used in the tenstovec command, which itself is only used in th
e mkb command which is never used. Thus this command is evidently obso
lete." }}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 358 "typet:=proc()
\nlocal tns,i,deg;\nif nargs=0 then \ntns:=ZEROTENS \nelse \ntns:=args
[1]\nfi;\nif not type(tns,list) then \nERROR(\"Tensor is ill defined\"
)\nfi;\nif tns=ZEROTENS then \nreturn(0)\nfi;\ndeg:=nops(tns[1][TMON_B
ASE]);\nfor i from 2 to nops(tns) do\nif nops(tns[i][TMON_BASE])<>deg \+
then \nERROR(\"Not all terms in the tensor have the same degree\") \nf
i;\nod;\ndeg;\nend:" }}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 395 
"typed:=proc()\nlocal cder,i,deg;\nif nargs=0 then cder:=d \nelse \ncd
er:=args[1]\nfi;\nif not type(cder,list) then \nERROR(\"Coderivation i
s ill defined\")\nfi;\nif cder=ZEROCODER then \nreturn(0)\nfi;\ndeg:=n
ops(cder[1][CMON_BASE][CBASE_LIST]);\nfor i from 2 to nops(cder) do\ni
f nops(cder[i][CMON_BASE][CBASE_LIST])<>deg then \nERROR(\"Not all ter
ms in the coderivation have the same degree\") \nfi;\nod;\ndeg;\nend:
" }}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 307 "dertomat:=proc(cde
r::list)\nlocal cbas,coef,cmon,l,i,j,m,n,c,A;\nl:=2:\nif nargs>1 then \+
\nl:=args[2]\nelse \nl:=typed(cder)\nfi;\nn:=num_chn(l);\nm:=DIMENSION
;\nA:=Matrix(m,n,0);\nfor cmon in cder do\ncbas:=cmon[CMON_BASE];\ncoe
f:=cmon[CMON_COEF];\nA[cbas[CBASE_INDEX],AC_inv(cbas[CBASE_LIST],l)]:=
coef;\nod;\neval(A);\nend:" }}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 
259 142 "vectotens:=proc(L::Vector,l::nonnegint)\nif Dimension(L)<>num
_chn(l) then \nERROR(\"Mismatch\") \nfi;\n[seq([AC(i,l),L[i]],i=1..Dim
ension(L))];\nend:" }}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 227 "
vectoder:=proc(L::Vector,l::nonnegint)\nlocal out,i,k;\nk:=log[DIMENSI
ON](Dimension(L))-1;\nif not type(k,nonnegint)then error(\"Improper Ve
ctor Size\")fi;\nout:=ZEROCODER;\nad(seq(mph(op(mk_cochn(i,k)),L[i]),i
=1..Dimension(L)));\nend:" }}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 
259 273 "tenstovec:=proc(tns::list)\nlocal i,l,n,out;\nif nargs>1 then
 l:=args[2]\nelse \nl:=typet(tns)\nfi;\nn:=num_chn(l);\nout:=Vector[ro
w]([seq(0,i=1..n)]);\nfor i from 1 to nops(tns) do\nout[AC_inv(tns[i][
TMON_BASE],l)]:=out[AC_inv(tns[i][TMON_BASE],l)]+tns[i][TMON_COEF];\no
d:\nout:\nend:" }}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 305 "dert
ovec:=proc(cder::list)\nlocal l,i,n,cmon,cbas,coef,out;\nl:=2:\nif nar
gs>1 then \nl:=args[2]\nelse \nl:=typed(cder)\nfi;\nn:=DIMENSION*num_c
hn(l);\nout:=Vector([seq(0,i=1..n)]);\nfor cmon in cder do\ncbas:=cmon
[CMON_BASE];\ncoef:=cmon[CMON_COEF];\nout[cochn_inv(cbas,l)]:=out[coch
n_inv(cbas,l)]+coef;\nod:\nout;\nend:" }}}{EXCHG {PARA 259 "> " 0 "" 
{MPLTEXT 1 259 145 "mkphs:=proc(k::nonnegint)\nlocal c,vec;\nif nargs>
1 then \nc:=args[2] \nfi;\nvec:=Vector([seq(c[i],i=1..DIMENSION*num_ch
n(k))]);\nvectoder(vec,k);\nend:" }}}{EXCHG {PARA 0 "" 0 "" {TEXT -1 
344 "The procedure countsol takes a set of linear equalities and count
s the number of such equalities whose left hand side is the same as th
e right hand side. This is used to count the number of free variables \+
which result from applying a linear operator to a generic basis elemen
t, which therefore gives the dimension of the kernel of the operator.
" }}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 122 "countsol:=proc(sol
)\nlocal i,cnt;cnt:=0;\nfor i to nops(sol) do\nif lhs(sol[i])=rhs(sol[
i]) then \ncnt:=cnt+1 fi;\nod;cnt;\nend:" }}}{EXCHG {PARA 0 "" 0 "" 
{TEXT -1 105 "The procedure grabsol does not seem to be used in any of
 the other procedures so it is probably obsolete." }}}{EXCHG {PARA 
259 "> " 0 "" {MPLTEXT 1 259 139 "grabsol:=proc(sol)\nlocal i,res;res:
=[];\nfor i to nops(sol) do\nif lhs(sol[i])=rhs(sol[i]) then \nres:=[o
p(res),lhs(sol[i])] \nfi;\nod;res;\nend:" }}}{EXCHG {PARA 0 "" 0 "" 
{TEXT -1 280 "The procedure sc strips out the coefficients of a coderi
vation and makes them into a set.  It is used as part of the method of
 solving for when the coefficients are zero, which is the key to findi
ng the kernel of the codifferential applied to some generic element of
 fixed degree." }}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 108 "sc:=
proc(cder)\nlocal res,i;\nres:=\{\};\nfor i to nops(cder) do\nres:=\{o
p(res),cder[i][CMON_COEF]\};\nod;\nres;\nend:" }}}{EXCHG {PARA 0 "" 0 
"" {TEXT -1 332 "The procedure mkcoh takes one argument n, which repre
sents the degree of the cochains to be studied. It returns the dimensi
on of the kernel of the coboundary operator applied to cochains of deg
ree n.  It has an optional second argument which represents the name g
iven to the variables used to create the generic cochain of degree n.
" }}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 240 "mkcoh:=proc(n::non
negint)\nglobal d;\nlocal i,j,x,res,ans,sol,vars;\nif nargs>1 then \nx
:=args[2] \nfi;\nres:=tb(d,mkphs(n,x)):\nans:=sc(res);\nvars:=\{seq(x[
i],i=1..DIMENSION*num_chn(n))\};\n#print(ans,vars);\nsol:=solve(ans,va
rs);\ncountsol(sol);\nend:" }}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 
259 386 "cntco:=proc()\nlocal deg,i,k,z,b,h,c,n;\nif type(d,list) then
 \ndeg:=typed(d)\nelse \nerror(\"The codifferential d is not defined\"
)\nfi; \nif nargs>=1 then \nk:=args[1]\nelse \nk:=DIMENSION+1 \nfi;\nf
or i from 0 to k do\nc:=num_chn(i)*DIMENSION;\nz:=mkcoh(i);\nif deg=1 \+
then \nh:=2*z-c;\nelif \ni< deg-1 then \nh:=z:\nelse \nh:=z-b[i-deg+1]
;\nfi;\nb[i]:=c-z:\nprint(\"Cohomology in dimension\",i,\"is\",h);\nod
;\nend:" }}}{EXCHG {PARA 0 "" 0 "" {TEXT -1 202 "The procedure mkq cre
ates the matrix of the extension of the linear automorphism g of the s
pace V to a map from V^k to V^k, where k is the argument of the proced
ure, which must be a nonnegative integer." }}}{EXCHG {PARA 259 "> " 0 
"" {MPLTEXT 1 259 161 "mkq:=proc()\nlocal i,j,k,l,n,A;\nglobal g;\nl:=
2:\nif nargs>0 then \nl:=args[1]fi;\nn:=num_chn(l);\nA:=Matrix(n,n,(i,
j)->product(g[AC(i,l)[k],AC(j,l)[k]],k=1..l)):\nend:" }}}{EXCHG {PARA 
0 "" 0 "" {TEXT -1 100 "The procedure mkb does not appear to be used i
n any of the other procedures so is probably obsolete." }}}{EXCHG 
{PARA 259 "> " 0 "" {MPLTEXT 1 259 339 "mkb:=proc()\nlocal B,l,i,vec,k
,n,m,vecs;\nglobal d;\nif type(d,list) then \nk:=typed(d)\nelse \nerro
r(d,\"is not a codifferential\")\nfi;\nl:=2*k-1:\nif nargs>1 then \nl:
=args[2] \nfi;\nm:=num_chn(l):\nn:=num_chn(l-k+1):\nvecs:=[]:\nB:=Matr
ix([seq(convert(tenstovec(apply_coder_tens(d,mk_tens(mk_tmon((AC(i,l))
))),l-k+1),list),i=1..n)]):\nTranspose(B);\nend:" }}}{EXCHG {PARA 0 "
" 0 "" {TEXT -1 0 "" }}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 384 
"mksol:=proc(vars)\nlocal i,j,neqs,deg,exeq;\nglobal M1,M2,allsol,A,g,
AA;\nexeq:=\{\};\nif nargs>1 then \nexeq:=args[2];\nfi;\nif nargs>2 th
en \ndeg:=args[3]; \nelif \ntype(d,list) then \ndeg:=typed(d); \nelse \+
\ndeg:=2;\nfi;\nM1:=simplify(A.mkq(deg)):\nM2:=mkq(1).AA:\nneqs:=[seq(
seq(M1[i,j]=M2[i,j],i=1..DIMENSION),j=1..num_chn(deg))]:\nallsol:=\{so
lve(\{op(neqs),op(exeq)\},\{op(vars)\})\}:\nnops(allsol);\nend:" }}}
{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 218 "mkm:=proc(L)\nlocal var
,eq,M,i,j,k,l;\nM:=Matrix(DIMENSION,DIMENSION,0);\nfor i from 1 to DIM
ENSION do \nfor j from 1 to DIMENSION do\nfor eq in L do \nvar:=lhs(eq
);\nif var=g[i,j] then \nM[i,j]:=rhs(eq) \nfi;\nod;od;od;\nM;\nend:" }
}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 589 "cksol:=proc()\n local
 i,dt,nosol,tmp;\n global allsol,thsols;\n nosol:=0;\n thsols:=[];\n t
mp:=1:\n if nargs>0 then\n  if args[nargs]='print=false' then tmp:=0 f
i:\n fi;\n for i from 1 to nops(allsol) do  \n  dt:=simplify(Determina
nt(mkm(allsol[i]))):\n  if dt <>0 then\n   nosol:=1;\n   thsols:=[op(t
hsols),i];\n   #print(\"determinant of solution\",i, factor(dt));\n   \+
#print(mkm(allsol[i]));\n  fi;\n od;\n if nosol=0 then \n  if tmp=1 th
en \n   print(\"No Solutions\");\n  fi:\n  return(false);\n else\n  if
 tmp=1 then\n   print(\"The solutions with nonzero determinant are\",t
hsols);\n  fi:\n  return(true);\n fi;\nend:" }}}{EXCHG {PARA 259 "> " 
0 "" {MPLTEXT 1 259 128 "getvars:=proc(A::Matrix)\nlocal i,j,vars;\nva
rs:=\{\};\nindets(\{seq(seq(A[i,j],i=1..RowDimension(A)),j=1..ColumnDi
mension(A))\});\nend:" }}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 
348 "whatrel:=proc(n)\nlocal dt,vartypes,eq,var;\nvartypes:=\{\};\nif \+
nargs=1 and type(exvar,set) then \nvartypes:=exvar; \nelse \nvartypes:
=args[2] \nfi;\nprint(mkm(allsol[n]));\ndt:=simplify(Determinant(mkm(a
llsol[n])));\nprint(determinant=factor(simplify(dt)));\nfor eq in alls
ol[n] do \nfor var in vartypes do\nif lhs(eq)=var then\nprint(factor(e
q))\nfi\nod;\nod;\nend:" }}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 
245 "stg:=proc(M::Matrix) \nglobal g,DIMENSION;\nlocal i,j;\nif RowDim
ension(M)<>DIMENSION or ColumnDimension(M)<> DIMENSION then \nerror(\"
Matrix has wrong size\") fi;\nfor i from 1 to DIMENSION do \nfor j fro
m 1 to DIMENSION do \ng[i,j]:=M[i,j]:\nod;od;\nend:" }}}{EXCHG {PARA 
259 "> " 0 "" {MPLTEXT 1 259 371 "sta:=proc(M::Matrix) \nglobal a,DIME
NSION;\nlocal i,j,k;\nk:=ColumnDimension(M);\nif nargs>1 then \nk:=arg
s[2] \nfi;\nif k<>ColumnDimension(M) then \nerror(\"Matrix has wrong n
umber of columns for stated degree\") \nfi;\nif RowDimension(M)<> DIME
NSION then \nerror(\"Matrix has wrong number of rows\") \nfi;\nfor i f
rom 1 to DIMENSION do \nfor j from 1 to k do \na[i,j]:=M[i,j]:\nod;od;
\nend:" }}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 254 "mkmatrix:=pr
oc(n)\nlocal i,j,deg,M;\nif type(d,list) then \ndeg:=typed(d)else erro
r(\"Can't find the degree of the codifferential\", d) \nfi;\nTranspose
(Matrix([seq(convert(dertovec(tb(d,mph(op(mk_cochn(i,n)))),n+deg-1),li
st),i=1..num_chn(n)*DIMENSION)]));\nend:" }}}{EXCHG {PARA 259 "> " 0 "
" {MPLTEXT 1 259 548 "cnker:=proc(A)\nlocal eq,cnt,C,Y,i,j,m,n,y,vartp
,vars,var;\nglobal THESOL;\nvars:=[];\nif nargs>1 then \nvars:=args[2]
 \nfi;\nm:=RowDimension(A);\nn:=ColumnDimension(A);\nY:=Matrix(n,1,[se
q([y[i]],i=1..n)]);\nC:=A.Y;\nTHESOL:=[solve(\{seq(C[i,1],i=1..m)\})]:
\nprint(\"Number of solutions:\",nops(THESOL));\nfor i from 1 to nops(
THESOL) do\ncnt:=n;vartp:=\{\}; \nfor eq in THESOL[i] do\nfor j from 1
 to n do \nif lhs(eq)=y[j] and rhs(eq)<>y[j] then \ncnt:=cnt-1 \nfi;od
;\nfor var in vars do \nif lhs(eq)=var then \nvartp:=\{op(vartp),eq\}
\nfi;od;\nod;\nprint([i,cnt,vartp]);od;\nend:" }}}{EXCHG {PARA 259 "> \+
" 0 "" {MPLTEXT 1 259 464 "Colbasis:=proc(A::Matrix)\nlocal i,rk,c,r,c
rk,k,nrk,out;\nk:=0;\nout:=[];\nc:=ColumnDimension(A);\nr:=RowDimensio
n(A);\nif nargs>1 and type(args[2],nonnegint) then \nk:=args[2] fi;\ni
f k>c then \nERROR(\"The Column dimension of the matrix is too small\"
) \nfi;\nrk:=0;\nnrk:=0; \nif k>0 then \nrk:=nops(RowSpace(SubMatrix(A
,1..r,1..k))); \nfi;\nfor i from k+1 to c do\nnrk:=nops(RowSpace(SubMa
trix(A,1..r,1..i)));\nif nrk>rk then \nrk:=nrk;out:=[op(out),Column(A,
i)];\nfi;\nod;\nout;\nend:" }}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 
259 597 "cohobasis:=proc(n::nonnegint)\nlocal k,i,cders,res,coh,vars,V
,coc,deg,Y,C,bas;\nif type(d,list) then \ndeg:=typed(d)\nelse \nerror(
\"Can't find the degree of the codifferential\", d) \nfi;\nvars:=\{\}:
\nif nargs=2 and type(args[2],set) then \nvars:=args[2] \nfi;\nV:=mkma
trix(n);\nif vars<>\{\} then \ncnker(V,vars)fi;\ncoc:=[op(NullSpace(V)
)];\nif coc=[] then return([])fi;\nY:=convert(coc,Matrix);\nif n<deg-1
 then\ncders:=map(vectoder,coc,n);\n#map(pc,cders):\nreturn(cders);\nf
i;\nV:=mkmatrix(n-deg+1);\nC:=<<V|Y>>;\nk:=ColumnDimension(V);\ncoh:=C
olbasis(C,k);\ncders:=map(vectoder,coh,n);\n#map(pc,cders):\nreturn(cd
ers);\nend:" }}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 77 "scmat:=p
roc(A::matrix)\n\{seq(seq(A[i,j],i=1..rowdim(A)),j=1..coldim(A))\}:\ne
nd:" }}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 216 "issamevec:=proc
(X::Vector,Y::Vector)\nlocal i,n;\nn:=Dimension(X); \nif Dimension(Y)<
>n then \nerror(\"Vectors have different lengths\")fi;\nfor i from 1 t
o n do\nif X[i]<>Y[i] then \nreturn(false) \nfi;\nod;\nreturn(true);\n
end:" }}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 493 "coboprebasis:=
proc(n::nonnegint)\nlocal i,j,k,V,B,vars,res;\nif type(d,list) then \n
k:=typed(d) \nelse \nerror(d,\"is not a codifferential\")\nfi;\nif n+1
 < k then \nreturn([])\nfi;\nvars:=\{\}:\nif nargs=2 and type(args[2],
set) then \nvars:=args[2] \nfi;\nres:=[];\nV:=mkmatrix(n-k+1);\nif var
s<>\{\} then \ncnker(V,vars)\nfi;\nB:=Colbasis(V);\nfor i from 1 to no
ps(B) do\nfor j from 1 to ColumnDimension(V) do\nif issamevec(B[i],Col
umn(V,j)) then \nres:=[op(res),mph(op(mk_cochn(j,n-k+1)))];\nbreak;\nf
i\nod;\nod;\nres: \nend:" }}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 
259 303 "assignphis:=proc(cders,psi)\nlocal i,k,par;\npar:=1; \nif nar
gs>2 then \npar:=args[3]\nfi;\nunassign('psi');\nk:=1;\nfor i from 1 t
o nops(cders)\ndo \nif parity_cbase(cders[i][CMON_BASE][CBASE_LIST])=p
ar then\npsi[k]:=cders[i];\nk:=k+1;\nfi; \nod;\nfor i from 1 to k-1 do
 \nprint(''psi''[i]=pnt_coder(psi[i])) \nod;\nend:" }}}{EXCHG {PARA 
259 "> " 0 "" {MPLTEXT 1 259 394 "cobobasis:=proc(n::nonnegint)\nlocal
 i,j,k,V,B,res,vars;\nif type(d,list) then \nk:=typed(d) \nelse \nerro
r(d,\"is not a codifferential\")\nfi;\nif n+1 < k then \nreturn([])\nf
i;\nres:=[];\nvars:=\{\}:\nif nargs=2 and type(args[2],set) then \nvar
s:=args[2] \nfi;\nV:=mkmatrix(n-k+1);\nif vars<>\{\} then \ncnker(V,va
rs)\nfi;\nB:=ColumnSpace(V):\nfor i from 1 to nops(B) do\nres:=[op(res
),vectoder(B[i],n)];\nod;\nres: \nend:" }}}{EXCHG {PARA 259 "> " 0 "" 
{MPLTEXT 1 259 136 "gettypes:=proc(L::list,p)\nlocal cder,res;\nres:=[
];\nfor cder in L do\nif parity_coder(cder)=p then \nres:=[op(res),cde
r] \nfi;\nod:\nres:\nend:" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 
2713 "versal:=proc(d)\nlocal i,k,ptst,nogood,j,m,dinf,\ntaus,numdeltas
,numgammas,numbetas,numtaus,numalphas,thebracket;\nglobal t,A,S,ASOL,P
SOL,DINF,RELS,_MaxSols,deltas,alphas,betas,gammas;\nif type(d,list) th
en \nk:=typed(d) \nelse \nerror(d,\"is not a codifferential\")\nfi;\nA
:=dertomat(d,k);\nif nargs>1 then \ndeltas:=gettypes(args[2],1):\nelse
\nprint(\"computing a basis of the cohomology in degree\",k);\ndeltas:
=gettypes(cohobasis(k,getvars(A)),1):\nprint(\"A basis of the cohomolo
gy in degree\",k);\nprint(map(pnt_coder,deltas));\nfi;\nnumdeltas:=nop
s(deltas);\nprint(\"The basis of the cohomology in degree\",k,\"has\",
numdeltas,\"elements.\");\nprint(\"computing a prebasis of the\",2*k-1
,\"coboundaries\");\ngammas:=gettypes(coboprebasis(2*k-1,getvars(A)),1
):\nnumgammas:=nops(gammas);\nprint(\"The prebasis of the coboundaries
 in degree\",k,\"has\",numgammas,\"elements.\");\nbetas:=[seq(mc(tb(d,
gammas[i]),2),i=1..numgammas)];\nprint(\"A basis of the coboundaries o
f degree\",2*k-1);\nprint(map(pnt_coder,betas));\nnumbetas:=nops(betas
);\nprint(\"The basis of the coboundaries in degree\",2*k-1,\"has\",nu
mbetas,\"elements.\");\nif nargs>2 then \nalphas:=gettypes(args[3],0);
 \nelse\nprint(\"computing a basis of the cohomology in degree\",2*k-1
);\nalphas:=gettypes(cohobasis(2*k-1,getvars(A)),0):\nfi;\nnumalphas:=
nops(alphas):\nprint(\"A basis of the cohomology in degree\",2*k-1);\n
print(map(pnt_coder,alphas));\nprint(\"The basis of the cohomology in \+
degree\",2*k-1,\"has\",numalphas,\"elements.\");\nprint(\"computing a \+
prebasis of the\",3*k-2,\"coboundaries\");\ntaus:=gettypes(coboprebasi
s(3*k-2,getvars(A)),0):\nnumtaus:=nops(taus):\nprint(\"The prebasis of
 the coboundaries in degree\",3*k-2,\"has\",numtaus,\"elements.\");\n#
print(map(pnt_coder,taus));\ndinf:=ad(d,seq(mult_coder_num('t'[i],delt
as[i]),i=1..numdeltas),seq(mult_coder_num('x'[i],gammas[i]),i=1..numga
mmas)):\nthebracket:=dertovec(tb(dinf,dinf)):\nprint(\"Computing the m
atrix of the versal deformation\");\nA:=ReducedRowEchelonForm(Matrix([
seq(dertovec(alphas[i]),i=1..numalphas),seq(dertovec(betas[i]),i=1..nu
mbetas),seq(dertovec(taus[i]),i=1..numtaus),thebracket]));\nRELS:=[seq
(A[i,numalphas+numbetas+numtaus+1],i=1..numalphas)];\nS:=\{seq(A[i,num
alphas+numbetas+numtaus+1],i=numalphas+1..numalphas+numbetas)\};\nASOL
:=\{\};\nprint(\"Solving for the x variables\");\nPSOL:=simplify([solv
e(S,\{seq('x'[i],i=1..numgammas)\})]);\nfor i from 1 to nops(PSOL) do
\nptst:=subs(seq(x[m]=0,m=1..numgammas),seq(t[m]=0,m=1..numdeltas),PSO
L[i]);\n#print(ptst);\nnogood:=0:\nfor j from 1 to nops(ptst)\ndo\nif \+
rhs(ptst[j])<>0 then nogood:=1;break;fi:\nod:\nif nogood=0 then ASOL:=
PSOL[i]:break;fi;\nod:\nprint(ASOL);#return;\nprint(\"Computing the ve
rsal deformation\");\nRELS:=\{op(subs(ASOL,RELS))\};\nDINF:=psubs(ASOL
,dinf):\nprint(\"Versal Deformation Computed\"):\nend:" }{TEXT -1 0 "
" }}}{EXCHG {PARA 272 "" 0 "" {TEXT 272 96 "The procedure ckit compare
s one codifferential versus all of the codifferentials in a dimension.
" }}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 1751 "ckit:=proc(der)\n
 local num,i,j,x,y,z,w,excond,exvars,mytype,svars,Mat1,Mat2,neqs,omit,
lvout,pnt;\n global A,AA,G,Q,vars,thsols,allsol,whichsol,MAXTYPE,_MaxS
ols;\n _MaxSols:=10000;\n AA:=dertomat(der,2);\n if nargs>1 then mytyp
e:=args[2];\n elif thetype<>\"\" then mytype:=thetype;\n else ERROR(\"
No type file to search specified\");\n fi:\n pnt:=typeoptions(initial=
[0,0],seq(args[i],i=1..nargs)):\n if nargs>2 then if nops(args[3])=1 t
hen x:=args[3]; fi;fi;\n if nargs>3 then if nops(args[4])=1 then y:=ar
gs[4]; fi;fi:\n if nargs>4 then if nops(args[5])=1 then z:=args[5]; fi
;fi;\n if nargs>5 then if nops(args[6])=1 then w:=args[6]; fi;fi;\n ex
vars:=\{\};\n omit:=\{\};\n if nargs>6 then \n  if type(args[7],set) t
hen \n   omit:=args[7]; \n  fi;\n fi;\n whichsol:=[];  \n for i from 1
 to mytype() do\n  if pnt[1]=1 then\n   print(\"Checking type\",i);\n \+
 fi;\n  if omit<>\{\} then\n   lvout:=0; \n   for j in omit do \n    i
f i=j then \n     if pnt[1]=1 then\n      print(\"omitting type\",i);
\n     fi;\n     lvout:=1;\n     break;\n    fi;\n   od;\n   if lvout=
1 then lvout:=0;next;fi;\n  fi:\n  if pnt[1]=1 then  \n   A:=dertomat(
mytype(i,x,y,z,w,print=true,shiftit=pnt[2]));\n  else\n   A:=dertomat(
mytype(i,x,y,z,w,print=false,shiftit=pnt[2]));\n  fi;\n  umkg();G:=mkg
():Q:=mkq():\n  vars:=\{op(exvars),op(getvars(A)),op(getvars(AA)),op(g
etvars(G))\};\n  svars:=\{op(exvars),op(getvars(A)),op(getvars(AA))\};
\n  excond:=\{\};\n  Mat1:=simplify(evalm(simplify(A&*Q))):\n  Mat2:=e
valm(G&*AA):\n  neqs:=[seq(seq(Mat1[i,j]=Mat2[i,j],i=1..DIMENSION),j=1
..num_chn(2))]:\n  allsol:=\{solve(\{op(neqs),op(excond)\},vars)\}:\n \+
 if pnt[1]=1 then \n   if cksol() then whichsol:=[op(whichsol),i] fi;
\n  else\n   if cksol(print=false) then whichsol:=[op(whichsol),i] fi;
\n  fi:\n od;\n print(\"The types with solutions are\",whichsol);\nend
:" }}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 1510 "ckit:=proc(der)
\n local num,i,j,x,y,z,w,excond,exvars,mytype,svars,Mat1,Mat2,neqs,omi
t,lvout,pnt;\n global A,AA,G,Q,vars,thsols,allsol,whichsol,MAXTYPE,_Ma
xSols;\n _MaxSols:=10000;\n AA:=dertomat(der,2);\n if nargs>1 then myt
ype:=args[2];\n elif thetype<>\"\" then mytype:=thetype;\n else ERROR(
\"No type file to search specified\");\n fi:\n pnt:=typeoptions(initia
l=[0,0],seq(args[i],i=1..nargs)):\n if nargs>2 then if nops(args[3])=1
 then x:=args[3]; fi;fi;\n if nargs>3 then if nops(args[4])=1 then y:=
args[4]; fi;fi:\n if nargs>4 then if nops(args[5])=1 then z:=args[5]; \+
fi;fi;\n if nargs>5 then if nops(args[6])=1 then w:=args[6]; fi;fi;\n \+
exvars:=\{\};\n omit:=\{\};\n if nargs>6 then \n  if type(args[7],set)
 then \n   omit:=args[7]; \n  fi;\n fi;\n whichsol:=[];  \n for i from
 1 to mytype() do\n  if i in omit then next fi;\n  if pnt[1]=1 then\n \+
    print(\"Checking type\",i);\n  fi;\n  A:=dertomat(mytype(i,x,y,z,w
,print=false,shiftit=pnt[2]));\n  umkg();G:=mkg():Q:=mkq():\n  vars:=
\{op(exvars),op(getvars(A)),op(getvars(AA)),op(getvars(G))\};\n  svars
:=\{op(exvars),op(getvars(A)),op(getvars(AA))\};\n  excond:=\{\};\n  M
at1:=simplify(A.Q):\n  Mat2:=simplify(G.AA):\n  neqs:=[seq(seq(Mat1[i,
j]=Mat2[i,j],i=1..DIMENSION),j=1..num_chn(2))]:\n  allsol:=\{solve(\{o
p(neqs),op(excond)\},vars)\}:\n  if pnt[1]=1 then \n   if cksol() then
 whichsol:=[op(whichsol),i] fi;\n  else\n   if cksol(print=false) then
 whichsol:=[op(whichsol),i] fi;\n  fi:\n od;\n print(\"The types with \+
solutions are\",whichsol);\nif nops(whichsol)>0 then return(true)else \+
return(false)fi;\nend:" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" 
}}}{EXCHG {PARA 272 "" 0 "" {TEXT 272 73 "The routine below is used af
ter the routine above to obtain the relations" }}}{EXCHG {PARA 0 "> " 
0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 
586 "compare:=proc(der1,der2)\nlocal num,i,x,y,z,w,excond,exvars,svars
,Mat1,Mat2,neqs;\nglobal A,AA,G,Q,vars,thsols,allsol,_MaxSols;\n_MaxSo
ls:=10000;\nAA:=dertomat(der2,2);\nexvars:=\{\};if nargs>2 then exvars
:=args[3]fi;  \nA:=dertomat(der1,2);\nprint(evalm(A),evalm(AA));\numkg
();G:=mkg():Q:=mkq():\nvars:=\{op(exvars),op(getvars(A)),op(getvars(AA
)),op(getvars(G))\};\nsvars:=\{op(exvars),op(getvars(A)),op(getvars(AA
))\};\nexcond:=\{\};\nMat1:=AA.Q:\nMat2:=G.A:\nneqs:=[seq(seq(Mat1[i,j
]=Mat2[i,j],i=1..DIMENSION),j=1..num_chn(2))]:\nallsol:=\{solve(\{op(n
eqs),op(excond)\},vars)\}:\ncksol():\n#allrels2(svars);\nend:" }}}
{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 588 "ncompare:=proc(der1,der
2)\nlocal num,i,x,y,z,w,excond,exvars,svars,Mat1,Mat2,neqs;\nglobal A,
AA,G,Q,vars,thsols,allsol,_MaxSols;\n_MaxSols:=10000;\nAA:=dertomat(de
r2,2);\nexvars:=\{\};if nargs>2 then exvars:=args[3]fi;  \nA:=dertomat
(der1,2);\n#print(evalm(A),evalm(AA));\numkg();G:=mkg():Q:=mkq():\nvar
s:=\{op(exvars),op(getvars(A)),op(getvars(AA)),op(getvars(G))\};\nsvar
s:=\{op(exvars),op(getvars(A)),op(getvars(AA))\};\nexcond:=\{\};\nMat1
:=AA.Q:\nMat2:=G.A:\nneqs:=[seq(seq(Mat1[i,j]=Mat2[i,j],i=1..DIMENSION
),j=1..num_chn(2))]:\nallsol:=\{solve(\{op(neqs),op(excond)\},vars)\}:
\ncksol():\n#allrels2(svars);\nend:" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 272 "" 0 "" {TEXT 272 86 "The routin
e below is used after the routine above, it displays the relavent rela
tions." }}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 258 "showrel:=pro
c()\nlocal num,L,exvars;\nglobal A,AA,G,Q,vars,thsols;\nL:=thsols;if n
args>0 then L:=args[1]fi;\nexvars:=\{\};if nargs>1 then exvars:=args[2
]fi;\nfor num in L\ndo\nprint(\"working on\",num);\nwhatrel(num,\{op(e
xvars),op(getvars(A)),op(getvars(AA))\});\nod:\nend:" }}}{EXCHG {PARA 
271 "" 0 "" {TEXT 271 70 "The routine below shifts the codifferential'
s elements up at least one" }}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 
259 684 "shiftit:=proc(cder)\n local out,n,cmon,coef,cod,i,ncod,j,k;\n
 if cder=ZEROCODER then return ZEROCODER fi;\n n:=1:\n if nargs>1 then
 n:=args[2] fi:\n out:=[]:\n if type(n,integer) then\n  for cmon in cd
er do\n   coef:=cmon[2];\n   cod:=cmon[1];\n   ncod:=[]:\n   for i to \+
nops(cod[1]) do\n    ncod:=[op(ncod),cod[1][i]+n]:\n   od;\n   out:=ad
(out,mph(ncod,cod[2]+n,coef)):\n  od;\n  return(out);\n fi;\n if type(
n,list) then\n  out:=cder;\n  for i to nops(n) do\n   for j to nops(cd
er) do\n    cmon:=cder[j][1];\n    for k to nops(cmon[1]) do\n     if \+
cmon[1][k]=i then\n      out[j][1][1][k]:=n[i];\n     fi;\n    od;\n  \+
  if cmon[2]=i then \n     out[j][1][2]:=n[i];\n    fi;\n   od;\n  od;
\n return(out);\n fi; \nend:" }}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 
1 259 49 "psubs:=proc(subseq,lst)pad(subs(subseq,lst)):end:" }}}
{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 402 "allrels2:=proc()\nlocal
 num, eq, var, vars,slop,AAA;\nglobal A,AA,thsols, allsol;\nvars:=\{\}
:if nargs>0 then vars:=args[1]fi;\nfor num in thsols do \nprint(\"work
ing on \",num):\nslop:=\{op(map(convert,[op(allsol[num])],radical))\}:
\nAAA:=mkm(slop):\nprint(AAA):\nprint(determinant=factor(simplify(Dete
rminant(AAA))));\nfor eq in slop do \nfor var in vars do\nif lhs(eq)=v
ar then\nprint(simplify(eq))\nfi\nod;\nod;\nod;\nend:" }}}{EXCHG 
{PARA 259 "> " 0 "" {MPLTEXT 1 259 606 "mk_ker:=proc(A::Matrix)\nlocal
 r,n,i,j,pivots,lastpivot,nulls,dims,res,B,vec,nullbas;\ndims:=Dimensi
on(A):\nlastpivot:=0;\npivots:=[];\nnullbas:=[];\nnulls:=[];\nB:=Reduc
edRowEchelonForm(A):\nfor i from 1 to dims[1]\ndo\nfor j from lastpivo
t+1 to dims[2]\ndo\nlastpivot:=j;\nif B[i,j]<>0 then \npivots:=[op(piv
ots),j];\nbreak;\nfi;\nnulls:=[op(nulls),j];\nod;\nod;\nnulls:=[op(nul
ls),seq(i,i=lastpivot+1..dims[2])];\nr:=nops(pivots);\nn:=nops(nulls);
\nfor j from 1 to n\ndo\nvec:=Vector([seq(0,i=1..dims[2])]);\nfor i fr
om 1 to r\ndo\nvec[pivots[i]]:=-B[i,nulls[j]];\nod;\nvec[nulls[j]]:=1;
\nnullbas:=[op(nullbas),vec];\nod;\nnullbas:\nend:" }}}{EXCHG {PARA 
273 "> " 0 "" {MPLTEXT 1 273 571 "Colbasis:=proc(A::Matrix)\nlocal B,i
,rk,c,r,dims,k,pivots,lastpivot,j;\nk:=0;lastpivot:=0;pivots:=[];\ndim
s:=[Dimension(A)];\n#c:=ColumnDimension(A);\n#r:=RowDimension(A);\nif \+
nargs>1 and type(args[2],nonnegint) then k:=args[2] fi;\nif k>dims[2] \+
then ERROR(\"The Column dimension of the matrix is too small\")fi;\nB:
=ReducedRowEchelonForm(A):\nfor i from 1 to dims[1]\ndo\nfor j from la
stpivot+1 to dims[2]\ndo\nif B[i,j]<>0 then \nif j>k then pivots:=[op(
pivots),j]fi;\nlastpivot:=j;\nbreak;\nfi;\nlastpivot:=j;\nod;\nif last
pivot=dims[2] then break fi;\nod;\nreturn([Column(A,pivots)]);  \nend:
" }}}{EXCHG {PARA 273 "> " 0 "" {MPLTEXT 1 273 172 "facent:=proc(A::Ma
trix)\nlocal i,j,B;\nB:=Matrix(Dimension(A)):\nfor i from 1 to RowDime
nsion(A)do\nfor j from 1 to ColumnDimension(A)do\nB[i,j]:=factor(A[i,j
]):\nod;\nod:\nB;\nend:" }}}{EXCHG {PARA 273 "> " 0 "" {MPLTEXT 1 273 
401 "extend:=proc(init)\nlocal i,tmp,tp,len,out,a;\ntmp:=[];\nout:=[]:
\nif init=[] then len:=0:else len:=nops(init[nops(init)]);fi:\nfor i t
o nops(init) \ndo\nif nops(init[i])=len then tmp:=[op(tmp),init[i]]:fi
;\nod;\nif len<PARITY then out:=[op(out),[op(tmp[1]),0]]fi;\nfor tp in
 tmp do\nif (add(tp[i],i=1..nops(tp))<(DIMENSION-PARITY) and nops(tp)<
DIMENSION-1) \nthen   \nout:=[op(out),[op(tp),1]]:\nfi:\nod:\nout:\nen
d: " }}}{EXCHG {PARA 273 "> " 0 "" {MPLTEXT 1 273 395 "mkgM:=proc()\nl
ocal L,gM,i,eL,oL,nume,numo,j;\nL:=[[]]:\nfor i to DIMENSION-1 do L:=[
op(L),op(extend(L))]:od;\nL:=[seq(L[i],i=2..nops(L))];\ngM:=L:\neL:=[s
eq(i,i=1..PARITY)]:\noL:=[seq(i,i=PARITY+1..DIMENSION)]:\nfor i to nop
s(L) do\nnume:=1:\nnumo:=1:\nfor j to nops(L[i]) do\nif L[i][j]=0 then
\ngM[i][j]:=eL[nume]:\nnume:=nume+1:\nfi:\nif L[i][j]=1 then \ngM[i][j
]:=oL[numo]:\nnumo:=numo+1:\nfi:\nod:\nod:\ngM;\nend:" }}}{EXCHG 
{PARA 273 "> " 0 "" {MPLTEXT 1 273 217 "mkgW:=proc(M1)\nlocal M,W,i,gW
,j;\ngW:=[]:\nfor j to nops(M1) do\nM:=sort(M1[j]):\nW:=[seq(i,i=1..DI
MENSION)];\nfor i to nops(M) do\nW[M[i]]:=0:\nod:\nW:=[op(\{op(W)\})]:
\nW:=[seq(W[i],i=2..nops(W))];\ngW:=[op(gW),W]:\nod;\ngW:\nend:" }}}
{EXCHG {PARA 273 "> " 0 "" {MPLTEXT 1 273 999 "gmaps:=proc(M1::list)\n
local ind,i,j,k,tmp;\nglobal M,W,glambda,gpsi,gbeta;\nif nops(M1)>DIME
NSION-1 or nops(M)<0 then error(\"M is too large or small\")fi:\nM:=so
rt(M1):\nW:=[seq(i,i=1..DIMENSION)];\nfor i to nops(M) do\nW[M[i]]:=0:
\nod:\nW:=[op(\{op(W)\})]:\nW:=[seq(W[i],i=2..nops(W))];\nglambda:=ZER
OCODER:\ngpsi:=ZEROCODER:\ngbeta:=ZEROCODER:\nind:=1:\nfor i to nops(W
) do\nfor j to nops(W) do\nfor k to nops(M) do\ntmp:=mph([W[i],W[j]],M
[k],c[ind]):\nif parity_coder(tmp)=1 then;\ngpsi:=ad(gpsi,tmp):\nind:=
ind+1:\nfi:\nod:\nod:\nod:\nind:=1:\nfor i to nops(W) do\nfor j to nop
s(M) do\ntmp:=mph([W[i]],M[j],b[ind]):\nif parity_coder(tmp)=0 then;\n
gbeta:=ad(gbeta,tmp):\nind:=ind+1:\nfi:\nod:\nod:\nmkdeltamu(M,W):\nGe
nG(M,W):\nnmkglambda();\nif nargs>1 and (args[2]='banana' or args[2]='
print') then  \n#print('lambda'=pnt_coder(glambda)):\nprint(mklmat(gla
mbda)):\nprint('psi'=pnt_coder(gpsi)):\nprint('beta'=pnt_coder(gbeta))
:\nprint(\"mu=mytypeM\"=mytypeM):\nprint(\"delta=mytypeW\"=mytypeW):\n
print('M'=M);\nprint('W'=W);\nprint('G'=G);\nfi;\nend:" }}}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 1817 "restrictions:=proc(mu,delta,M1::l
ist)\nlocal i,anslam,ansmc,lambda,bracdlp,bracmc,ans,psi,mbcobound,ans
l:\nglobal TH:\nbracdlp:=proc(delta,lambda,psi)\nlocal dl, ans,temp,i;
\ndl:=ad(delta,lambda):\nans:=[op(\{solve(sc(tb(dl,psi)))\})]:\ntemp:=
[]:\nif ans=[] then\nreturn([[lambda,psi]]):\nelse\nfor i to nops(ans)
 do\ntemp:=[op(temp),[subs(ans[i],lambda),subs(ans[i],psi)]]:\nod:\nfi
:\nreturn(temp):\nend:\nbracmc:=proc(delta,mu,lambda,psi)\nlocal ans,t
emp,i;\nans:=[op(\{solve(sc(ad(tb(delta,lambda),mc(tb(lambda,lambda),1
/2),tb(mu,psi))))\})];\ntemp:=[]:\nif ans=[] then \nreturn([[lambda,ps
i]]);\nelse\nfor i to nops(ans) do\ntemp:=[op(temp),[subs(ans[i],lambd
a),subs(ans[i],psi)]];\nod:\nfi:\nreturn(temp):\nend:\nmbcobound:=proc
(res)\nlocal i,result,ans,dum,mbco,j;\nresult:=res;\nfor i to nops(res
ult) do\nmbco:=ad(tb(mu,gbeta),result[i]):\nans:=[op(\{solve(sc(mbco))
\})]:\nif tb(mu,gbeta)<>ZEROCODER then\ndum:=[1,nops(mbco)]:\nfor j to
 nops(ans) do\nif nops(subs(ans[j],mbco))<dum[2] then\ndum:=[j,nops(su
bs(ans[j],mbco))]:\nfi;\nod;\nif ans<>[] then\nresult[i]:=subs(ans[dum
[1]],mbco):\nfi:\nfi:\nod;\n  result:=[op(\{op(result)\})];\n end:\n g
maps(M1):\n ansl:=[op(\{solve(sc(tb(mu,glambda)))\})]:\n anslam:=[]:\n
 if ansl=[] then\n  anslam:=[glambda]:\n else\n  for i to nops(ansl) d
o \n   lambda:=subs(ansl[i],glambda): \n   anslam:=[op(anslam),lambda]
: \n  od:\n fi:\n anslam:=mbcobound(anslam):\n ansmc:=[]: \n for i to \+
nops(anslam) do   \n   lambda:=anslam[i]:\n   ansmc:=[op(ansmc),op(bra
cmc(delta,mu,lambda,gpsi))];\n od:\n ans:=[]:\n for i to nops(ansmc) d
o\n   ans:=[op(ans),op(bracdlp(delta,ansmc[i][1],ansmc[i][2]))]:\n od:
\n if nargs>3 then \n  if args[4]='print' then\n   for i to nops(ans) \+
do\n    print('lambda'=pnt_coder(ans[i][1]));\n    print('psi'=pnt_cod
er(ans[i][2]));\n    print(\"-----------------------------------------
-------------------\"):\n   od;\n  fi;\n fi;\n ans:\nend:" }}}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 137 "mkd:=proc(clist)\n local out,i:\n \+
out:=[]:\n for i to nops(clist) do;\n  out:=[op(out),ad(delta,mu,clist
[i][1],clist[i][2])];\n od;\n out;\nend:" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 89 "parity_base:=proc(tbas::list)\n nops(tbas)-add(parity
_elem(tbas[i]),i=1..nops(tbas));\nend:" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 311 "mkdeltamu:=proc(M,W)\n global mytypeM,mytypeW;\n if \+
parity_base(M)=nops(M) then\n  mytypeM:=atypex0;\n else\n  mytypeM:=at
ype||(parity_base(M))||(nops(M)-parity_base(M));\n fi:\n if parity_bas
e(W)=nops(W) then\n  mytypeW:=atypex0;\n else  \n  mytypeW:=atype||(pa
rity_base(W))||(nops(W)-parity_base(W));\n fi;\n return;\nend:" }}}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 157 "GenG:=proc()\n local i,j;\n
 global g,G,M,W;\n umkg():\n for i to nops(M) do\n  for j to nops(W) d
o\n   g[M[i],W[j]]:=0;g[W[j],M[i]]:=0:\n  od;\n od;\n G:=mkg();\n end:
" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 35 "fsubs:=proc()factor(sub
s(args))end:" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 2640 "deform:=p
roc(d,n)\nlocal alp,alphas,gam,gammas,bet,betas,tau,taus,res,res1,ans,
dinf,tst,i,j,zerox,thes,ans1;\nglobal t,DINF,RELS,Z,ZZ;\nprint(\"Compu
ting a basis of the 2-cocycles\"):\nres:=gettypes(cohobasis(2),1);\npr
int(map(pnt_coder,res));\ndinf:=factor(ad(d,seq(mc(res[i],t[i]),i=1..n
ops(res)))):\npc(dinf);\ntst:=pad(factor(tb(dinf,dinf))):\nif tst=ZERO
CODER then\nprint(\"The infinitesimal deformation is versal and there \+
are no relations\"):\nDINF:=dinf;RELS:=\{\}:\nreturn():\nfi;\nprint(\"
Computing a basis of the 3-cocycles\"):\nalp:=gettypes(cohobasis(3),0)
:print(map(pnt_coder,alp));\nalphas:=ad(seq(mc(alp[i],-r[i]),i=1..nops
(alp))):\nprint(\"Computing a prebasis of the 3-coboundaries\"):\ngam:
=gettypes(coboprebasis(3),1):\ngammas:=ad(seq(mc(gam[i],x[i]),i=1..nop
s(gam))):\nprint(\"Computing a basis of the 3-coboundaries\"):\nbet:=[
seq(mc(tb(d,gam[i]),-2),i=1..nops(gam))]:\nbetas:=ad(seq(mc(tb(d,gam[i
]),2*s[i]),i=1..nops(gam))):\nprint(\"Computing a prebasis of the 4-co
boundaries\"):\ntau:=gettypes(coboprebasis(4),0):\nprint(\"The number \+
of 4-coboundaries is\",nops(tau));\ntaus:=ad(seq(mc(tau[i],u[i]),i=1..
nops(tau))):\nprint(\"Computing the versal deformation\");\nDINF:=ad(d
inf,gammas);\nres:=ad(tb(DINF,DINF),betas,alphas,taus);\nans:=solve(sc
(res),\{seq(r[i],i=1..nops(alp)),seq(s[i],i=1..nops(gam)),seq(u[i],i=1
..nops(tau))\});\nRELS:=subs(ans,\{seq(r[i],i=1..nops(alp))\}):\nZZ:=[
seq(0,i=1..nops(gam))];\nres1:=subs(seq(x[i]=0,i=1..nops(gam)),ans);\n
for j from 1 to n do:\nprint(\"Computing the\",j,\"th order deformatio
n\");\nZ:=factor(subs(res1,[seq(s[i],i=1..nops(gam))]));\nprint('Z'=Z)
:\nif Z=[seq(0,i=1..nops(gam))]\nthen\nprint(\"The versal deformation \+
is given by the\", j,\"th order deformation\"):\nDINF:=pad(factor(subs
(seq(x[i]=ZZ[i],i=1..nops(gam)),DINF)));\n#RELS:=subs(res1,\{seq(r[i],
i=1..nops(alp))\});\nRELS:=subs(seq(x[i]=ZZ[i],i=1..nops(gam)),RELS);
\nprint(\"Versal Deformation Computed\");\nreturn():\nfi;\nfor i from \+
1 to nops(gam) do ZZ[i]:=ZZ[i]+Z[i];od;\nres1:=subs(seq(x[i]=ZZ[i],i=1
..nops(gam)),ans);\nod;\n#print('Z'=subs(res1,[seq(s[i],i=1..nops(gam)
)]));\n#ZZ:=subs(res1,[seq(u[i],i=1..nops(tau))]);\n#pc(subs(seq(u[i]=
ZZ[i],i=1..nops(tau)),taus));\nprint(\"Versal Deformation not given by
 the\",n,\"order deformation, attempting to compute it another way.\")
;\nZ:=factor(subs(res1,[seq(s[i],i=1..nops(gam))]));\nzerox:=\{\};\nfo
r i from 1 to nops(gam) do if ZZ[i]=0 then zerox:=\{op(zerox),x[i]=0\}
 fi od;\nthes:=subs(ans,[seq(s[i],i=1..nops(gam))]);\nprint([zerox,the
s]);\nprint(\"solving for the x variables\");\nans1:=solve(\{op(zerox)
,op(thes)\},\{seq(x[i],i=1..nops(gam))\});\nDINF:=pad(factor(subs(ans1
,DINF)));\nRELS:=\{op(subs(ans1,RELS))\};\nprint(\"Versal deformation \+
Computed\");\nend:" }{TEXT -1 0 "" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 428 "findopp:=proc()\nlocal coef,omit,cmon,cbas,clist,cin
d,der,nder;\nglobal d;\nif nargs<>0 then der:=args[1];else der:=d;fi;
\nomit:=\{\};if nargs>1 then omit:=args[2];fi;\nnder:=ZEROCODER;\nfor \+
cmon in der do\ncbas:=cmon[1];\nclist:=cbas[1]:\ncind:=cbas[2]:\ncoef:
=sgn(parity_tbas(cbas[1]))*cmon[2];\nnder:=ad(nder,mph([clist[2],clist
[1]],cind,coef)):\nod;\npc(nder):\nif nargs>1 then ckit(nder,thetype,x
,y,z,w,omit):else ckit(nder):fi;\nnder;\nend:" }}}{EXCHG {PARA 0 "> " 
0 "" {MPLTEXT 1 0 249 "ckans:=proc(n)\nlocal eqn,res;\nres:=\{seq(fsub
s(seq(t[i]=0,i=1..100),lhs(ans[n][i]))=fsubs(seq(t[i]=0,i=1..100),nume
r(rhs(ans[n][i]))),i=1..nops(ans[n]))\};\nprint(res):\nfor eqn in res \+
do if lhs(eqn)<>rhs(eqn) then return(false)fi;od;\nreturn(true):\nend:
" }}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 346 "ncntco:=proc()\nlo
cal deg,i,k,res,odds;\nif type(d,list) then \ndeg:=typed(d)\nelse \ner
ror(\"The codifferential d is not defined\")\nfi; \nif nargs>=1 then \+
\nk:=args[1]\nelse \nk:=DIMENSION+1 \nfi;\nfor i from 0 to k do\nres:=
cohobasis(i):\nodds:=gettypes(res,1):\nprint(sprintf(`Cohomology in di
mension %d is %d|%d`,i,nops(res)-nops(odds),nops(odds)));\nod;\nend:" 
}}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}}{EXCHG {PARA 0 "> " 
0 "" {MPLTEXT 1 0 0 "" }}}}{MARK "18 0 0" 0 }{VIEWOPTS 1 1 0 1 1 1803 
1 1 1 1 }{PAGENUMBERS 0 1 2 33 1 1 }
