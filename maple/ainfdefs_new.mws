{VERSION 6 0 "IBM INTEL NT" "6.0" }
{USTYLETAB {CSTYLE "Maple Input" -1 0 "Courier" 0 1 255 0 0 1 0 1 0 0 
1 0 0 0 0 1 }{CSTYLE "2D Math" -1 2 "Times" 0 1 0 0 0 0 0 0 2 0 0 0 0 
0 0 1 }{CSTYLE "2D Comment" 2 18 "" 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 }
{CSTYLE "_cstyle3" -1 256 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 0 0 0 1 }
{CSTYLE "_cstyle4" -1 257 "Courier" 1 12 255 0 0 1 2 1 2 2 1 2 0 0 0 
1 }{CSTYLE "_cstyle5" -1 258 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 0 0 0 1 
}{CSTYLE "_cstyle6" -1 259 "Courier" 1 12 255 0 0 1 2 1 2 2 1 2 0 0 0 
1 }{CSTYLE "_cstyle7" -1 260 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 0 0 0 1 
}{CSTYLE "_cstyle8" -1 261 "Times" 1 18 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }
{CSTYLE "_cstyle9" -1 262 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 0 0 0 1 }
{CSTYLE "_cstyle10" -1 263 "Times" 1 14 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }
{CSTYLE "_cstyle11" -1 264 "Courier" 1 12 255 0 0 1 2 1 2 2 1 2 0 0 0 
1 }{CSTYLE "_cstyle12" -1 265 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 0 0 0 
1 }{CSTYLE "_cstyle13" -1 266 "Courier" 1 12 255 0 0 1 2 1 2 2 1 2 0 
0 0 1 }{CSTYLE "_cstyle14" -1 267 "Times" 1 14 0 0 0 1 2 1 2 2 2 2 0 
0 0 1 }{CSTYLE "_cstyle1" -1 268 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 0 0 
0 1 }{CSTYLE "_cstyle15" -1 269 "Times" 1 18 0 0 0 1 2 1 2 2 2 2 0 0 
0 1 }{CSTYLE "_cstyle16" -1 270 "Times" 1 14 0 0 0 1 2 1 2 2 2 2 0 0 
0 1 }{CSTYLE "_cstyle17" -1 271 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 0 0 
0 1 }{CSTYLE "_cstyle18" -1 272 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 0 0 
0 1 }{CSTYLE "_cstyle19" -1 273 "Courier" 1 12 255 0 0 1 2 1 2 2 1 2 
0 0 0 1 }{CSTYLE "_cstyle20" -1 274 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 
0 0 0 1 }{PSTYLE "Normal" -1 0 1 {CSTYLE "" -1 -1 "Times" 1 12 0 0 0 
1 2 2 2 2 2 2 1 1 1 1 }1 1 0 0 0 0 1 0 1 0 2 2 0 1 }{PSTYLE "_pstyle11
" -1 256 1 {CSTYLE "" -1 -1 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 1 1 1 1 }
1 1 0 0 0 0 2 0 2 0 2 2 0 1 }{PSTYLE "_pstyle12" -1 257 1 {CSTYLE "" 
-1 -1 "Courier" 1 12 255 0 0 1 2 1 2 2 1 2 1 1 1 1 }1 1 0 0 0 0 2 0 2 
0 2 2 0 1 }{PSTYLE "_pstyle13" -1 258 1 {CSTYLE "" -1 -1 "Times" 1 12 
0 0 0 1 2 2 2 2 2 2 1 1 1 1 }1 1 0 0 0 0 2 0 2 0 2 2 0 1 }{PSTYLE "_ps
tyle14" -1 259 1 {CSTYLE "" -1 -1 "Courier" 1 12 255 0 0 1 2 1 2 2 1 
2 1 1 1 1 }1 1 0 0 0 0 2 0 2 0 2 2 0 1 }{PSTYLE "_pstyle15" -1 260 1 
{CSTYLE "" -1 -1 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 1 1 1 1 }1 1 0 0 0 
0 2 0 2 0 2 2 0 1 }{PSTYLE "_pstyle16" -1 261 1 {CSTYLE "" -1 -1 "Time
s" 1 18 0 0 0 1 2 1 2 2 2 2 1 1 1 1 }1 1 0 0 8 4 2 0 2 0 2 2 0 1 }
{PSTYLE "_pstyle70" -1 262 1 {CSTYLE "" -1 -1 "Times" 1 12 0 0 0 1 2 
2 2 2 2 2 1 1 1 1 }1 1 0 0 0 0 2 0 2 0 2 2 0 1 }{PSTYLE "_pstyle71" 
-1 263 1 {CSTYLE "" -1 -1 "Times" 1 14 0 0 0 1 2 1 2 2 2 2 1 1 1 1 }1 
1 0 0 8 2 2 0 2 0 2 2 0 1 }{PSTYLE "_pstyle72" -1 264 1 {CSTYLE "" -1 
-1 "Courier" 1 12 255 0 0 1 2 1 2 2 1 2 1 1 1 1 }1 1 0 0 0 0 2 0 2 0 
2 2 0 1 }{PSTYLE "_pstyle73" -1 265 1 {CSTYLE "" -1 -1 "Times" 1 12 0 
0 0 1 2 2 2 2 2 2 1 1 1 1 }1 1 0 0 0 0 2 0 2 0 2 2 0 1 }{PSTYLE "_psty
le74" -1 266 1 {CSTYLE "" -1 -1 "Courier" 1 12 255 0 0 1 2 1 2 2 1 2 
1 1 1 1 }1 1 0 0 0 0 2 0 2 0 2 2 0 1 }{PSTYLE "_pstyle75" -1 267 1 
{CSTYLE "" -1 -1 "Times" 1 14 0 0 0 1 2 1 2 2 2 2 1 1 1 1 }1 1 0 0 8 
2 2 0 2 0 2 2 0 1 }{PSTYLE "_pstyle9" -1 268 1 {CSTYLE "" -1 -1 "Times
" 1 12 0 0 0 1 2 2 2 2 2 2 1 1 1 1 }1 1 0 0 0 0 2 0 2 0 2 2 0 1 }
{PSTYLE "_pstyle76" -1 269 1 {CSTYLE "" -1 -1 "Times" 1 18 0 0 0 1 2 
1 2 2 2 2 1 1 1 1 }1 1 0 0 8 4 2 0 2 0 2 2 0 1 }{PSTYLE "_pstyle77" 
-1 270 1 {CSTYLE "" -1 -1 "Times" 1 14 0 0 0 1 2 1 2 2 2 2 1 1 1 1 }1 
1 0 0 8 2 2 0 2 0 2 2 0 1 }{PSTYLE "_pstyle78" -1 271 1 {CSTYLE "" -1 
-1 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 1 1 1 1 }1 1 0 0 0 0 2 0 2 0 2 2 
0 1 }{PSTYLE "_pstyle79" -1 272 1 {CSTYLE "" -1 -1 "Times" 1 12 0 0 0 
1 2 2 2 2 2 2 1 1 1 1 }1 1 0 0 0 0 2 0 2 0 2 2 0 1 }{PSTYLE "_pstyle80
" -1 273 1 {CSTYLE "" -1 -1 "Courier" 1 12 255 0 0 1 2 1 2 2 1 2 1 1 
1 1 }1 1 0 0 0 0 2 0 2 0 2 2 0 1 }{PSTYLE "_pstyle81" -1 274 1 
{CSTYLE "" -1 -1 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 1 1 1 1 }1 1 0 0 0 
0 2 0 2 0 2 2 0 1 }}
{SECT 0 {PARA 0 "" 0 "" {TEXT -1 0 "" }}{PARA 256 "" 0 "" {TEXT 256 
110 "The first  PARITY elements in the basis of the vector space will \+
be considered even, and all the rest are odd." }}{EXCHG {PARA 257 "> \+
" 0 "" {MPLTEXT 1 257 24 "PARITY:=0:\nDIMENSION:=1:" }}}{EXCHG {PARA 
258 "" 0 "" {TEXT 258 35 "The following defines even and odd." }}}
{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 16 "ODD:=1:\nEVEN:=0:" }}}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 19 "_MaxSols:=infinity:" }}}
{PARA 256 "" 0 "" {TEXT 256 51 "The parity of an element is defined us
ing the above" }}{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 1 257 87 "parity_
elem:=proc(i::posint) \n  if i<=PARITY then \n    return(0)\n  fi;\n  \+
return(1)\nend:" }}}{PARA 256 "" 0 "" {TEXT 256 42 "The following comp
utes -1 to the argument." }}{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 1 257 
27 "sgn:=proc(a)\n  (-1)^a;\nend:" }}}{PARA 256 "" 0 "" {TEXT 256 74 "
This is the Kronecker delta function.  It returns 1 if i = j and 0 if \+
not." }}{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 1 257 72 "deltaij:=proc(i,
j)\n  if i=j then \n    return(1);\n  fi;\n  return(0);\nend:" }}}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{SECT 0 {PARA 261 "" 0 "
" {TEXT 261 17 "Tensor Operations" }}{PARA 262 "" 0 "" {TEXT 262 53 "A
 basic element of the tensor algebra is of the form " }{XPPEDIT 18 0 "
e_I" "6#%$e_IG" }{TEXT 262 36 "  where I is a list of indices ....." }
}{SECT 0 {PARA 263 "" 0 "" {TEXT 263 12 "Tensor Bases" }}{PARA 256 "" 
0 "" {TEXT 256 43 "The base for the one tensor is given below." }}
{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 1 257 8 "ONE:=[]:" }}}{PARA 256 "
" 0 "" {TEXT 256 58 "The command below multiplies the bases for a vect
or space." }}{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 1 257 70 "mult_tbas:=
proc(base1::list,base2::list)\n  [op(base1),op(base2)]\nend: " }}}
{PARA 256 "" 0 "" {TEXT 256 74 "The parity of a basis element in the t
ensor algebra is defined as follows." }}{EXCHG {PARA 257 "> " 0 "" 
{MPLTEXT 1 257 125 "parity_tbas:=proc(tbas::list)\n  if tbas=ONE then \+
\n    return(0)\n  fi;\n  add(parity_elem(tbas[i]),i=1..nops(tbas)) mo
d 2;\nend:" }}}{PARA 260 "" 0 "" {TEXT 260 0 "" }}}{SECT 0 {PARA 263 "
" 0 "" {TEXT 263 30 "Simple Coefficient Procedures " }}{PARA 256 "" 0 
"" {TEXT 256 37 "This is the zero and one coefficient." }}{EXCHG 
{PARA 257 "> " 0 "" {MPLTEXT 1 257 24 "ZEROCOEF:=0:\nONECOEF:=1:" }}}
{PARA 256 "" 0 "" {TEXT 256 36 "The command below adds coefficients." 
}}{EXCHG {PARA 264 "> " 0 "" {MPLTEXT 1 264 31 "add_coef:=proc(a,b)\n \+
 a+b;\nend:" }}}{PARA 256 "" 0 "" {TEXT 256 42 "The command below muli
tplies coefficients." }}{EXCHG {PARA 264 "> " 0 "" {MPLTEXT 1 264 32 "
mult_coef:=proc(a,b)\n  a*b;\nend:" }}}{PARA 256 "" 0 "" {TEXT 256 33 
"Convert a number to a coefficient" }}{EXCHG {PARA 257 "> " 0 "" 
{MPLTEXT 1 257 52 "mk_num_coef:=proc(a)\n  mult_coef_num(ONECOEF,a)\ne
nd:" }}}{PARA 265 "" 0 "" {TEXT 265 46 "A simple rule for the parity o
f a coefficient." }}{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 1 257 30 "pari
ty_coef:=proc(c)\n  0;\nend:" }}}{PARA 256 "" 0 "" {TEXT 256 59 "A sim
ple way to multipy a coefficient by an ordinary number" }}{EXCHG 
{PARA 257 "> " 0 "" {MPLTEXT 1 257 47 "mult_coef_num:=proc(coef,num) \+
\n  coef*num \nend:" }}}{PARA 256 "" 0 "" {TEXT 256 36 "The way to pri
nt normal coefficients" }}{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 1 257 
27 "pnt_coef:=proc(a)\n  a;\nend:" }}}{PARA 256 "" 0 "" {TEXT 256 55 "
Multiply a tensor monomial on the left by a coefficient" }}{EXCHG 
{PARA 257 "> " 0 "" {MPLTEXT 1 257 200 "lmult_tmon_coef:=proc(coef,tmo
n)\n  local c;\n  c:=sgn(parity_coef(coef)*parity_tbase(tmon[TMON_BASE
]));\n  c:=mult_coef_num(coef,c);\n  c:=mult_coef(c,tmon[TMON_COEF]);
\n  mk_tmon(tmon[TMON_BASE],c);\nend:" }}}{PARA 256 "" 0 "" {TEXT 256 
45 "Multply a tensor on the left by a coefficient" }}{EXCHG {PARA 257 
"> " 0 "" {MPLTEXT 1 257 243 "lmult_tens_coef:=proc(coef,tens)\n  loca
l i,res;\n  if tens=ZEROTENS then \n    return(ZEROTENS)\n  fi;\n  res
:=ZEROTENS;\n  for i to nops(tens) do\n    res:=add_tens(res,\n       \+
  mk_tens(lmult_tmon_coef(coef,tens[i])));\n  od;\n  comb_tens(res);\n
end:" }}}{PARA 256 "" 0 "" {TEXT 256 56 "Multiply a tensor monomial on
 the right by a coefficient" }}{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 1 
257 97 "rmult_tmon_coef:=proc(tmon,coef)\n  mk_tmon(tmon[TMON_BASE],mu
lt_coef(tmon[TMON_COEF],coef));\nend:" }}}{PARA 256 "" 0 "" {TEXT 256 
47 "Multiply a tensor on the right by a coefficient" }}{EXCHG {PARA 
257 "> " 0 "" {MPLTEXT 1 257 238 "rmult_tens_coef:=proc(tens,coef)\n  \+
local i,res;\n  if tens=ZEROTENS then \n    return(ZEROTENS)\n  fi;\n \+
 res:=ZEROTENS;\n  for i to nops(tens) do\n    res:=add_tens(res,\n   \+
 mk_tens(rmult_tmon_coef(tens[i],coef)));\n  od;\n  comb_tens(res);\ne
nd:" }}}{PARA 256 "" 0 "" {TEXT 256 29 "Multiply a tensor by a number
" }}{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 1 257 76 "mult_tens_num:=proc(
num,tens)\n  rmult_tens_coef(tens,mk_num_coef(num));\nend:" }}}{PARA 
260 "" 0 "" {TEXT 260 0 "" }}}{SECT 0 {PARA 263 "" 0 "" {TEXT 263 16 "
Tensor Monomials" }}{PARA 265 "" 0 "" {TEXT 265 89 "The command below \+
designates the position of the coefficient and the base in a monomial.
 " }}{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 1 257 27 "TMON_BASE:=1:\nTMON
_COEF:=2:" }}}{PARA 256 "" 0 "" {TEXT 256 45 "The one and zero monomia
ls are defined below." }}{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 1 257 49 
"ONETMON:=[ONE,ONECOEF]:\nZEROTMON:=[ONE,ZEROCOEF]:" }}}{PARA 256 "" 
0 "" {TEXT 256 71 "The command below constructs a monomial from a base
 and a coefficient. " }}{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 1 257 221 
"mk_tmon:=proc(base::list)\n  local coef,c;\n  coef:=ONECOEF; \n  if n
args>1 then \n    coef:=args[2]\n  fi;\n  if coef<>ZEROCOEF then\n    \+
c[TMON_BASE]:=base:\n    c[TMON_COEF]:=coef:\n    return([c[1],c[2]]):
\n  fi;\nZEROTMON;\nend:" }}}{PARA 256 "" 0 "" {TEXT 256 43 "The parit
y of a monomial is computed below." }}{EXCHG {PARA 257 "> " 0 "" 
{MPLTEXT 1 257 97 "parity_tmon:=proc(tmon)\n  parity_tbas(tmon[TMON_BA
SE])+parity_coef(tmon[TMON_COEF])   mod 2;\nend:" }}}{PARA 256 "" 0 "
" {TEXT 256 62 "This program computes the exterior degree of a tensor \+
monomial" }}{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 1 257 52 "degree_tmon:
=proc(tmon)\n  nops(tmon[TMON_BASE])\nend:" }}}{PARA 260 "" 0 "" 
{TEXT 260 0 "" }}}{SECT 0 {PARA 263 "" 0 "" {TEXT 263 7 "Tensors" }}
{PARA 256 "" 0 "" {TEXT 256 43 "The one and zero tensors are defined b
elow." }}{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 1 257 33 "ZEROTENS:=[]:\n
ONETENS:=[ONETMON]:" }}}{PARA 256 "" 0 "" {TEXT 256 51 "The command be
low makes a tensor out of a monomial." }}{EXCHG {PARA 257 "> " 0 "" 
{MPLTEXT 1 257 85 "mk_tens:=proc(tmon)\n  if tmon=ZEROTMON then \n    \+
return(ZEROTENS)\n  fi;\n  [tmon]\nend:" }}}{PARA 256 "" 0 "" {TEXT 
256 44 "The command below adds two tensors together." }}{EXCHG {PARA 
257 "> " 0 "" {MPLTEXT 1 257 76 "add_tens:=proc(tensor1::list,tensor2:
:list)\n  [op(tensor1),op(tensor2)]\nend:" }}}{PARA 256 "" 0 "" {TEXT 
256 66 "The command below simplifies a tensor by combining its like te
rms." }}{EXCHG {PARA 266 "> " 0 "" {MPLTEXT 1 266 682 "comb_tens:=proc
(tensor::list)\n  local final,rest,i,coef,base;\n  if tensor=ZEROTENS \+
then \n    return ZEROTENS \n  fi;\n  rest:=ZEROTENS;\n  coef:=tensor[
1][TMON_COEF];\n  base:=tensor[1][TMON_BASE];\n  for i from 2 to nops(
tensor) do\n    if tensor[i][TMON_BASE]=base then\n      coef:=add_coe
f(coef,tensor[i][TMON_COEF])\n    else\n      rest:=add_tens(rest,mk_t
ens(tensor[i]))\n    fi;\n  od;\n  if coef<> ZEROCOEF then\n    if res
t<>ZEROTENS then\n      final:=add_tens(mk_tens(mk_tmon(base,\n      c
oef)),comb_tens(rest));\n    else\n      final:=mk_tens(mk_tmon(base,c
oef));\n    fi;\n  else\n    if rest<>ZEROTENS then\n    final:=comb_t
ens(rest);\n    else\n      final:=ZEROTENS;\n    fi;\n  fi;\nend:" }}
}{PARA 256 "" 0 "" {TEXT 256 50 "The command below multiplies two tens
ors together." }}{EXCHG {PARA 266 "> " 0 "" {MPLTEXT 1 266 467 "mult_t
ens:=proc(tens1,tens2)\n  local i,j,coef,final;\n  final:=ZEROTENS;\n \+
 for i to nops(tens1) do\n    for j to nops(tens2) do\n      coef:=(-1
)^(parity_coef(tens1[i][TMON_COEF])*\n       parity_tbas(tens2[j][TMON
_BASE]));\n      coef:=mult_coef_num(mult_coef(tens1[i][TMON_COEF],\n \+
      tens2[j][TMON_COEF]),coef);\n      final:=add_tens(final,mk_tens
(mk_tmon(mult_tbas(\n       tens1[i][TMON_BASE],tens2[j][TMON_BASE]),c
oef)));\n      od;\n    od; \n  comb_tens(final);\nend:" }}}{PARA 256 
"" 0 "" {TEXT 256 115 "This routine gives the part of a tensor consist
ing of all monomials of degree less than or equal to a cutoff value." 
}}{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 1 257 249 "cutoff_tens:=proc(ten
s,cutoff)\n  local i,res;\n  if tens=ZEROTENS then \n    return ZEROTE
NS \n  fi;\n  res:=ZEROTENS;\n  for i to nops(tens)do\n    if degree_t
mon(tens[i])<=cutoff then \n      res:=add_tens(res,mk_tens(tens[i]));
\n    fi;\n  od;\n  res;\nend:" }}}{PARA 260 "" 0 "" {TEXT 260 0 "" }}
}{SECT 0 {PARA 267 "" 0 "" {TEXT 267 22 "Prettyprinting Tensors" }}
{PARA 256 "" 0 "" {TEXT 256 61 "The following prints a tensor basis el
ement in standard form." }}{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 1 257 
98 "pnt_tbase:=proc(tbas)\n  local out;\n  if tbas=ONE then \n    retu
rn(1);\n  fi;\n  out:='e'[tbas];\nend:" }}}{PARA 260 "" 0 "" {TEXT 
260 0 "" }}{PARA 256 "" 0 "" {TEXT 256 56 "The following prints a tens
or monomial in standard form." }}{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 
1 257 153 "pnt_tmon:=proc(tmon)\nlocal coef,tbas;\nif  tmon=[] then \n
return(0);\nfi;\ncoef:=tmon[TMON_COEF];\ntbas:=tmon[TMON_BASE];\npnt_t
base(tbas)*pnt_coef(coef);\nend:" }}}{PARA 256 "" 0 "" {TEXT 256 69 "T
he following prints a tensor as a sum of monomials in standard form." 
}}{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 1 257 110 "pnt_tens:=proc(tens)
\nlocal i;\nif tens=ZEROTENS then \nreturn(0)fi;\nadd(pnt_tmon(tens[i]
),i=1..nops(tens));\nend:" }}}{PARA 260 "" 0 "" {TEXT 260 0 "" }}}}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{SECT 0 {PARA 269 "" 0 "
" {TEXT 269 17 "Coderivation Code" }}{PARA 258 "" 0 "" {TEXT 258 0 "" 
}}{SECT 0 {PARA 270 "" 0 "" {TEXT 270 12 "Coefficients" }}{PARA 256 "
" 0 "" {TEXT 256 39 "Modify the routines here as appropriate" }}{PARA 
256 "" 0 "" {TEXT 256 59 "The following program gives the parity of ou
r coefficients." }}{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 1 257 29 "parit
y_coef:=proc()\n  0;\nend:" }}}{PARA 256 "" 0 "" {TEXT 256 69 "Multipl
ication of coderivation monomials on the left by a coefficient" }}
{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 1 257 236 "lmult_cmon_coef:=proc(a
,L)\n  local res,cbas,ccoef,par,coef;\n  cbas:=L[CMON_BASE];\n  ccoef:
=L[CMON_COEF];\n  par:=(-1)^(parity_cbase(cbas)*parity_coef(ccoef));\n
  coef:=mult_coef(mult_coef_num(a,par),ccoef);\n  res:=mk_cmon(cbas,co
ef);\nend:" }}}{PARA 256 "" 0 "" {TEXT 256 71 "Multiplication of coder
ivation monomials on the right by a coefficient." }}{EXCHG {PARA 257 "
> " 0 "" {MPLTEXT 1 257 164 "rmult_cmon_coef:=proc(L,a)\n  local res,c
bas,ccoef,par,coef;\n  cbas:=L[CMON_BASE];\n  ccoef:=L[CMON_COEF];\n  \+
coef:=mult_coef(ccoef,a);\n  res:=mk_cmon(cbas,coef);\nend:" }}}{PARA 
256 "" 0 "" {TEXT 256 52 "Multiplication of coderivation monomials by \+
a number" }}{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 1 257 114 "mult_cmon_n
um:=proc(n,cmon)\n  local res,coef;\n  coef:=mult_coef_num(ONECOEF,n);
\n  lmult_cmon_coef(coef,cmon);\nend:" }}}{PARA 256 "" 0 "" {TEXT 256 
62 "Left multiplication of a general coderivation by a coefficient" }}
{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 1 257 188 "lmult_coder_coef:=proc(
a,coder)\n  local i, res, mon;\n  res:=ZEROCODER;\n  for i to nops(cod
er) do\n    mon:=lmult_cmon_coef(a,coder[i]);\n    res:=[op(res),mon];
\n  od;\n  comb_coder(res);\nend:" }}}{PARA 256 "" 0 "" {TEXT 256 63 "
Right multiplication of a general coderivation by a coefficient" }}
{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 1 257 170 "rmult_coder_coef:=proc(
coder,a)\nlocal i, res, mon;\nres:=ZEROCODER;\nfor i to nops(coder) do
\nmon:=rmult_cmon_coef(coder[i],a);\nres:=[op(res),mon];\nod;\ncomb_co
der(res);\nend:" }}}{PARA 256 "" 0 "" {TEXT 256 52 "Multiplication of \+
a general coderivation by a number" }}{EXCHG {PARA 257 "> " 0 "" 
{MPLTEXT 1 257 112 "mult_coder_num:=proc(n,coder)\nlocal res,coef;\nco
ef:=mult_coef_num(ONECOEF,n);\nlmult_coder_coef(coef,coder);\nend:" }}
}{PARA 256 "" 0 "" {TEXT 256 22 "Printing a coefficient" }}{EXCHG 
{PARA 257 "> " 0 "" {MPLTEXT 1 257 23 "pnt_coef:=proc(c)c;end:" }}}
{PARA 258 "" 0 "" {TEXT 258 0 "" }}}{SECT 0 {PARA 270 "" 0 "" {TEXT 
270 18 "Coderivation Bases" }}{PARA 256 "" 0 "" {TEXT 256 74 "We desig
nate the positions of the list and index in the coderivation base." }}
{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 1 257 30 "CBASE_LIST:=1:\nCBASE_IN
DEX:=2:" }}}{PARA 256 "" 0 "" {TEXT 256 59 "The command below makes a \+
cbase out of a list and an index." }}{EXCHG {PARA 257 "> " 0 "" 
{MPLTEXT 1 257 125 "mk_cbase:=proc(List,index)\n  local out, res;\n  r
es[CBASE_LIST]:=List;\n  res[CBASE_INDEX]:=index;\n  out:=[res[1],res[
2]];\nend:" }}}{PARA 256 "" 0 "" {TEXT 256 57 "The program below find \+
the parity of a coderivation base." }}{EXCHG {PARA 257 "> " 0 "" 
{MPLTEXT 1 257 142 "parity_cbase:=proc(cbas::[list,posint])  \n  local
 i,par;\n  par:=(parity_elem(cbas[CBASE_INDEX])+\n   parity_tbas(cbas[
CBASE_LIST])) mod 2;\nend:" }}}{PARA 256 "" 0 "" {TEXT 256 63 "The pro
gram below applies a coderivation base to a tensor base." }}{EXCHG 
{PARA 257 "> " 0 "" {MPLTEXT 1 257 501 "apply_cbase_tbas:=proc(cbas::[
list,posint],tbas::list)\n  local res,j,J,k,coef,derterm,otbas,derlist
;\n  res:=ZEROTENS;\n  J:=cbas[CBASE_LIST];\n  j:=cbas[CBASE_INDEX];\n
  if tbas=ONE then \n    return(ZEROTENS)\n  fi;\n  for k from 0 to no
ps(tbas)-nops(J) do\n    coef:=deltaij(J,tbas[k+1..k+nops(J)])*\n     \+
sgn(parity_tbas(tbas[1..k])*parity_cbase(cbas));\n    otbas:=[op(tbas[
1..k]),j,\n     op(tbas[k+nops(J)+1..nops(tbas)])];\n    res:=add_tens
(res,mk_tens(mk_tmon(otbas,coef)));\n  od;\n  comb_tens(res);\nend:" }
}}{PARA 256 "" 0 "" {TEXT 256 67 "The program below applies a coderiva
tion base to a tensor monomial." }}{EXCHG {PARA 257 "> " 0 "" 
{MPLTEXT 1 257 181 "apply_cbase_tmon:=proc(cbas,tmon)\n  local res,coe
f,tbas;\n  tbas:=tmon[TMON_BASE];\n  coef:=tmon[TMON_COEF];\n  res:=ap
ply_cbase_tbas(cbas,tbas);\n  res:=rmult_tens_coef(res,coef);\nend:" }
}}{PARA 258 "" 0 "" {TEXT 258 58 "This next program applies a coderiva
tion base to a tensor." }}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 
176 "apply_cbase_tens:=proc(cbas,tens)\n  local res,tmon;\n  res:=ZERO
TENS;\n  for tmon in tens do\n    res:=add_tens(res,apply_cbase_tmon(c
bas,tmon));\n  od;\n  res:=comb_tens(res);\nend:" }}}{PARA 258 "" 0 "
" {TEXT 258 0 "" }}}{SECT 0 {PARA 270 "" 0 "" {TEXT 270 22 "Coderivati
on Monomials" }}{PARA 256 "" 0 "" {TEXT 256 79 "We designate positions
 for the base and coeficient in the coderivation monomial" }}{EXCHG 
{PARA 257 "> " 0 "" {MPLTEXT 1 257 27 "CMON_BASE:=1:\nCMON_COEF:=2:" }
}}{PARA 256 "" 0 "" {TEXT 256 76 "The command below makes coderivation
 monomials from a base and a coeficient." }}{EXCHG {PARA 257 "> " 0 "
" {MPLTEXT 1 257 170 "mk_cmon:=proc(cbas)\n  local res,coef;\n  res[CM
ON_BASE]:=cbas:\n  coef:=ONECOEF;\n  if nargs>1 then \n    coef:=args[
2];\n  fi;\n  res[CMON_COEF]:=coef;\n  [res[1],res[2]];\nend:" }}}
{PARA 256 "" 0 "" {TEXT 256 62 "The program below finds the parity of \+
a coderivation monomial." }}{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 1 257 
101 "parity_cmon:=proc(cmon) \n  parity_cbase(cmon[CMON_BASE])+\n   pa
rity_coef(cmon[CMON_COEF]) mod 2;\nend:" }}}{PARA 256 "" 0 "" {TEXT 
256 62 "The program below applies a coderivation monomial to a tensor.
" }}{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 1 257 207 "apply_cmon_tens:=pr
oc(cmon,tens)\n  local cbas,coef,res,ntens;\n  res:=ZEROTENS;\n  cbas:
=cmon[CMON_BASE];\n  coef:=cmon[CMON_COEF];\n  ntens:=lmult_tens_coef(
coef,tens);\n  res:=apply_cbase_tens(cbas,ntens);\nend:" }}}{PARA 258 
"" 0 "" {TEXT 258 0 "" }}}{SECT 0 {PARA 270 "" 0 "" {TEXT 270 13 "Code
rivations" }}{PARA 256 "" 0 "" {TEXT 256 22 "The zero coderivation." }
}{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 1 257 14 "ZEROCODER:=[]:" }}}
{PARA 256 "" 0 "" {TEXT 256 68 "The command below makes a coderivation
 from a coderivation monomial." }}{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 
1 257 34 "mk_coder:=proc(cmon)\n  [cmon]\nend:" }}}{PARA 256 "" 0 "" 
{TEXT 256 48 "The command below adds two derivations together." }}
{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 1 257 61 "add_coder:=proc(coder1,c
oder2)\n  [op(coder1),op(coder2)]\nend:" }}}{PARA 258 "" 0 "" {TEXT 
258 77 "The command below determines the parity, if well defined,  of \+
a coderivation." }}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 282 "pari
ty_coder:=proc(cder::list)\n  local i,p;\n  if cder=ZEROCODER then \n \+
   return(0) \n  fi;\n  p:=parity_cmon(cder[1]);\n  for i from 2 to no
ps(cder) do\n    if parity_cmon(cder[i])<>p then \n      ERROR(\"Parit
y of this coderivation is not \n       well defined\");\n    fi\n  od;
 \n  p;\nend:" }}}{PARA 256 "" 0 "" {TEXT 256 72 "The command below si
mplifies a coderivation by combining its like terms." }}{EXCHG {PARA 
257 "> " 0 "" {MPLTEXT 1 257 685 "comb_coder:=proc(coder)\n  local fin
al,rest,i,coef,base;\n  if coder=ZEROCODER then \n    return ZEROCODER
 \n  fi;\n  rest:=ZEROCODER;\n  coef:=coder[1][CMON_COEF];\n  base:=co
der[1][CMON_BASE];\n  for i from 2 to nops(coder) do\n    if coder[i][
CMON_BASE]=base then\n      coef:=add_coef(coef,coder[i][CMON_COEF])\n
    else\n      rest:=add_coder(rest,mk_coder(coder[i]))\n    fi;\n  o
d;\n  if coef<> ZEROCOEF then\n    if rest<>ZEROCODER then\n      fina
l:=add_coder(mk_coder(mk_cmon(base,coef)),\n       comb_coder(rest));
\n    else\n      final:=mk_coder(mk_cmon(base,coef));\n    fi;\n  els
e\n    if rest<>ZEROCODER then\n      final:=comb_coder(rest);\n    el
se\n      final:=ZEROCODER;\n    fi;\n  fi;\nend:" }}}{PARA 258 "" 0 "
" {TEXT 258 67 "The command below will add and simplify a sequence of \+
coderivations" }}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 105 "ad:=pr
oc()\n  local i,out;\n  out:=ZEROCODER;\n  out:=[seq(op(args[i]),i=1..
nargs)];\n  comb_coder(out);\nend:" }}}{PARA 256 "" 0 "" {TEXT 256 57 
"The following program applies a coderivation to a tensor." }}{EXCHG 
{PARA 257 "> " 0 "" {MPLTEXT 1 257 148 "apply_coder_tens:=proc(coder,t
ens)\n  local res,i;\n  res:=[seq(op(apply_cmon_tens(coder[i],tens)),
\n   i=1..nops(coder))];\n  res:=comb_tens(res);\nend:" }}}{PARA 258 "
" 0 "" {TEXT 258 0 "" }}}{SECT 0 {PARA 270 "" 0 "" {TEXT 270 25 "Brack
ets of Coderivations" }}{PARA 256 "" 0 "" {TEXT 256 63 "This routine c
omputes the composition of two coderivation bases" }}{EXCHG {PARA 257 
"> " 0 "" {MPLTEXT 1 257 319 "comp_cbase:=proc(cbas1,cbas2)\nlocal out
,J,j,K,k;\nJ:=cbas1[CBASE_LIST];\nj:=cbas1[CBASE_INDEX];\nK:=cbas2[CBA
SE_LIST];\nk:=cbas2[CBASE_INDEX];\nout:=[seq(mk_cmon([[op(J[1..i-1]),o
p(K),op(J[i+1..nops(J)])],j],mk_num_coef(deltaij(J[i],k)*sgn(parity_tb
as(J[1..i-1])*parity_cbase(cbas2))\n)),i=1..nops(J))];\ncomb_coder(out
);\nend:" }}}{PARA 256 "" 0 "" {TEXT 256 73 "The routine below compute
s the composition of two coderivation monomials." }}{EXCHG {PARA 257 "
> " 0 "" {MPLTEXT 1 257 351 "comp_cmon:=proc(cmon1,cmon2)\nlocal cbas1
,cbas2,coef1,coef2,num,coef,res;\ncbas1:=cmon1[CMON_BASE];\ncbas2:=cmo
n2[CMON_BASE];\ncoef1:=cmon1[CMON_COEF];\ncoef2:=cmon2[CMON_COEF];\nnu
m:=sgn(parity_coef(coef1)*parity_cbase(cbas2));\ncoef:=mult_coef(coef1
,coef2);\ncoef:=mult_coef_num(coef,num);\nres:=comp_cbase(cbas1,cbas2)
;\nres:=rmult_coder_coef(res,coef);\nend:" }}}{PARA 256 "" 0 "" {TEXT 
256 62 "The routine below computes the composition of two derivations.
" }}{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 1 257 194 "comp_coder:=proc(co
der1,coder2)\nlocal i,j, res;\nres:=ZEROCODER;\nfor i to nops(coder1) \+
do\nfor j to nops(coder2) do\nres:=add_coder(res,comp_cmon(coder1[i],c
oder2[j]));\nod;od;\ncomb_coder(res);\nend:" }}}{PARA 256 "" 0 "" 
{TEXT 256 64 "The routine below computes the bracket of two coderivati
on bases" }}{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 1 257 230 "brack_cbase
:=proc(cbas1,cbas2)\nlocal res1,res2,num,coef;\nres1:=comp_cbase(cbas1
,cbas2);\nres2:=comp_cbase(cbas2,cbas1);\nnum:=sgn(parity_cbase(cbas1)
*parity_cbase(cbas2)+1);\ncomb_coder(add_coder(res1,mult_coder_num(num
,res2)));\nend:" }}}{PARA 256 "" 0 "" {TEXT 256 69 "The routine below \+
computes the bracket of two coderivation monomials." }}{EXCHG {PARA 
257 "> " 0 "" {MPLTEXT 1 257 225 "brack_cmon:=proc(cmon1,cmon2)\nlocal
 res1,res2,num,coef;\nres1:=comp_cmon(cmon1,cmon2);\nres2:=comp_cmon(c
mon2,cmon1);\nnum:=sgn(parity_cmon(cmon1)*parity_cmon(cmon2)+1);\ncomb
_coder(add_coder(res1,mult_coder_num(num,res2)));\nend:" }}}{PARA 256 
"" 0 "" {TEXT 256 65 "The routine below computes the bracket of two ge
neral derivations" }}{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 1 257 196 "br
ack_coder:=proc(coder1,coder2)\nlocal i,j, res;\nres:=ZEROCODER;\nfor \+
i to nops(coder1) do\nfor j to nops(coder2) do\nres:=add_coder(res,bra
ck_cmon(coder1[i],coder2[j]));\nod;od;\ncomb_coder(res);\nend:" }}}
{PARA 258 "" 0 "" {TEXT 258 0 "" }}}{SECT 0 {PARA 270 "" 0 "" {TEXT 
270 12 "Exponentials" }}{PARA 268 "" 0 "" {TEXT 268 0 "" }}{EXCHG 
{PARA 257 "> " 0 "" {MPLTEXT 1 257 104 "adm:= proc(mu,delta,m::nonnegi
nt)\nif m=0 then \nreturn(delta) \nfi;\nbrack_coder(mu,adm(mu,delta,m-
1))\nend:" }}}{PARA 256 "" 0 "" {TEXT 256 24 "The function   e^(-adm).
" }}{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 1 257 192 "expm:=proc(mu,delta
,m::nonnegint)\nlocal i,out,res;\nres:=delta;\nfor i from 1 to m do\no
ut:=adm(mu,delta,i);\nout:=mult_coder_num((-1)^i/i!,out);\nres:=add_co
der(res,out);\nod;\ncomb_coder(res);\nend:" }}}{EXCHG {PARA 257 "> " 
0 "" {MPLTEXT 1 257 121 "power_coder:=proc(mu,tens,n::nonnegint)\nif n
=0 then \nreturn(tens)\nfi;\napply_coder_tens(mu,power_coder(mu,tens,n
-1));\nend:" }}}{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 1 257 200 "exp_cod
er:=proc(mu,tens,m::nonnegint)\nlocal i,term, res;\nres:=tens;\nfor i \+
from 1 to m do\nterm:=power_coder(mu,tens,i);\nterm:=mult_tens_num(1/i
!,term);\nres:=add_tens(res,term);\nod;\ncomb_tens(res);\nend:" }}}
{PARA 258 "" 0 "" {TEXT 258 0 "" }}}{SECT 0 {PARA 270 "" 0 "" {TEXT 
270 28 "Prettyprinting Coderivations" }}{PARA 256 "" 0 "" {TEXT 256 
67 "The following prints a coderivation basis element in standard form
." }}{EXCHG {PARA 257 "> " 0 "" {MPLTEXT 1 257 198 "pnt_cbase:=proc(cb
as)\nlocal out,thelist,theindex;\nthelist:=cbas[CBASE_LIST];\ntheindex
:=cbas[CBASE_INDEX];\nif parity_cbase(cbas)=0 then\n'phi'[theindex]^th
elist;\nelse\n'psi'[theindex]^thelist;\nfi;\nend:" }}}{PARA 268 "" 0 "
" {TEXT 268 0 "" }}{PARA 256 "" 0 "" {TEXT 256 62 "The following print
s a coderivation monomial in standard form." }}{EXCHG {PARA 257 "> " 
0 "" {MPLTEXT 1 257 120 "pnt_cmon:=proc(cmon)\nlocal coef,cbas;\ncoef:
=cmon[CMON_COEF];\ncbas:=cmon[CMON_BASE];\npnt_cbase(cbas)*pnt_coef(co
ef);\nend:" }}}{PARA 256 "" 0 "" {TEXT 256 75 "The following prints a \+
coderivation as a sum of monomials in standard form." }}{EXCHG {PARA 
257 "> " 0 "" {MPLTEXT 1 257 117 "pnt_coder:=proc(coder)\nlocal i;\nif
 coder=ZEROCODER then \nreturn(0)\nfi;\nadd(pnt_cmon(coder[i]),i=1..no
ps(coder));\nend:" }}}{PARA 256 "" 0 "" {TEXT 256 62 "This routine sho
ws how the coderivation is applied to a tensor" }}{EXCHG {PARA 257 "> \+
" 0 "" {MPLTEXT 1 257 137 "showder:=proc(coder,tens)\nlocal res;\nres:
=apply_coder_tens(coder,tens);\nprint((pnt_coder(coder)*pnt_tens(tens)
)=pnt_tens(res));\nres;\nend:" }}}{PARA 258 "" 0 "" {TEXT 258 0 "" }}}
{SECT 0 {PARA 270 "" 0 "" {TEXT 270 22 "User Freindly Routines" }}
{PARA 258 "" 0 "" {TEXT 258 98 "The following routine allows the const
ruction of a coderivation from a base, an index and a number" }}
{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 160 "mph:=proc(J,j,c)\nlocal
 cbas,cmon,coder,coef;\ncoef:=1;\nif nargs = 3 then \ncoef:=c \nfi;\nc
bas:=mk_cbase(J,j);\ncmon:=mk_cmon(cbas,coef);\ncoder:=mk_coder(cmon);
\nend:" }}}{PARA 258 "" 0 "" {TEXT 258 78 "The following routine multi
plies a coderivation on the right by a coefficient." }}{EXCHG {PARA 
259 "> " 0 "" {MPLTEXT 1 259 51 "mc:=proc(cder,coef)rmult_coder_coef(c
der,coef):end:" }}}{PARA 258 "" 0 "" {TEXT 258 60 "The following routi
ne prints a coderivation in readable form" }}{EXCHG {PARA 259 "> " 0 "
" {MPLTEXT 1 259 36 "pc:=proc(L)\nprint(pnt_coder(L))\nend:" }}}{PARA 
258 "" 0 "" {TEXT 258 78 "The following routine computes a bracket of \+
two coderivations in readable form" }}{EXCHG {PARA 259 "> " 0 "" 
{MPLTEXT 1 259 23 "pb:=proc(coder1,coder2)" }}{PARA 259 "> " 0 "" 
{MPLTEXT 1 259 83 "print([pnt_coder(coder1),pnt_coder(coder2)]=pnt_cod
er(brack_coder(coder1,coder2))):" }}{PARA 259 "> " 0 "" {MPLTEXT 1 
259 4 "end:" }}}{PARA 258 "" 0 "" {TEXT 258 62 "The following is a sho
rt hand version of the bracket operation" }}{EXCHG {PARA 259 "> " 0 "
" {MPLTEXT 1 259 51 "tb:=proc(cder1,cder2)\nbrack_coder(cder1,cder2)\n
end:" }}}{PARA 258 "" 0 "" {TEXT 258 90 "The following prints the brac
ket of two coderivations, without printing the coderivations." }}
{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 82 "sb:=proc(cder1,cder2)\nl
ocal res;\nres:=brack_coder(cder1,cder2);\npc(res);\nres;\nend:" }}}
{PARA 258 "" 0 "" {TEXT 258 96 "The following routine adds a sequence \+
of coderivations and prints the result in a readable form." }}{EXCHG 
{PARA 259 "> " 0 "" {MPLTEXT 1 259 138 "pad:=proc()\nlocal i,out;\nout
:=ZEROCODER;\nfor i from 1 to nargs do \nout:=[op(out),op(args[i])]\no
d;\nout:=comb_coder(out);\npc(out);\nout;\nend:" }}}{PARA 258 "" 0 "" 
{TEXT 258 0 "" }}}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}
{SECT 0 {PARA 269 "" 0 "" {TEXT 269 16 " A-infinity Code" }}{EXCHG 
{PARA 259 "> " 0 "" {MPLTEXT 1 259 20 "with(LinearAlgebra):" }}}
{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 31 "interface(rtablesize=inf
inity):" }}}{EXCHG {PARA 271 "" 0 "" {TEXT 271 87 "BC makes a list of \+
length N with l one's and the rest zeros. Returns the nth such list." 
}}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 356 "BC:=proc(n::posint,N
::posint,l::nonnegint)\nlocal i,k,x,h,res,out;\nif n>binomial(N,l) the
n \nERROR(\"n exceeds the maximum\") \nfi;\nif l=0 then \nreturn([seq(
0,i=1..N)]);\nelif \nl=1 then \nreturn([seq(0,i=1..n-1),1,seq(0,i=n+1.
.N)])\nfi;\nx:=0;\nh:=binomial(x+l-l,l);\nwhile h < n do\nk:=n-h;\nx:=
x+1;\nh:=binomial(x+l-1,l);\nod;\nres:=BC(k,N,l-1);\nres[x+l-1]:=1;\nr
es:\nend:" }}}{EXCHG {PARA 271 "" 0 "" {TEXT 271 65 "RC returns a list
 of the positions of one's in the original list." }}}{EXCHG {PARA 259 
"> " 0 "" {MPLTEXT 1 259 124 "RC:=proc(lst::list)\nlocal i,out;\nout:=
[];\nfor i from 1 to nops(lst) do \nif lst[i]=1 then \nout:=[op(out),i
] \nfi;od;\nout;\nend:" }}}{EXCHG {PARA 271 "" 0 "" {TEXT 271 57 "AC r
eturns the nth basis element of a tensor of degree k." }}}{EXCHG 
{PARA 259 "> " 0 "" {MPLTEXT 1 259 718 "AC:=proc(n::posint,k::nonnegin
t)\nlocal i,j,r,s,t,u,m,res,bn,out;\nif k=0 \nthen \nif n>1 then \nERR
OR(\"n is too large\") \nfi;\nreturn([])\nfi;\nif k=1 then \nreturn([n
])\nfi;\nm:=0;\nwhile true do\nif (m+1)^k<n then \nm:=m+1;\nnext; \nfi
;\nbreak;\nod;\nr:=0;\nwhile true do \nif n>add(binomial(k,l)*m^(k-l),
l=0..r+1) then \nr:=r+1;\nnext;\nfi;break;od;\ns:=n-add(binomial(k,l)*
m^(k-l),l=0..r);\nt:=0;\nwhile true do \nif (t+1)*m^(k-r-1)<s then \nt
:=t+1;\nnext;fi;\nbreak;od;\nu:=s-t*m^(k-r-1);\nres:=AC(u,k-r-1);\n#pr
int([m,r,s,t,u],[u,k-r-1],[t,k,r+1],res);\nbn:=BC(t+1,k,k-r-1);\nout:=
[seq(0,i=1..k)];\n#print([m,r,s,t,u],[u,k-r-1],res,bn);\ni:=1;\nfor j \+
from 1 to k do \nif bn[j]=0 then \nout[j]:=m+1 \nelse\nout[j]:=res[i];
\ni:=i+1;\nfi od;\nreturn(out);\nend:\n" }}}{EXCHG {PARA 271 "" 0 "" 
{TEXT 271 133 "BC_inv takes a list that tells which spaces are nonzero
 spaces of the tensor algebra and gives the number it is in our ordere
d basis." }}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 238 "BC_inv:=pr
oc(L)\nlocal l,n,N,K,M,i,j;\nl:=add(L[i],i=1..nops(L));\nn:=0;\nif l=0
 then \nreturn(1)\nfi;\nN:=nops(L);\nK:=L;\nfor i from 0 to N-1 do\nif
 L[N-i]=0 then \nnext \nfi; \nK[N-i]:=K[N-i]-1;\nn:=binomial(N-i-1,l);
\nbreak;\nod;\nn:=n+BC_inv(K);\nend:" }}}{EXCHG {PARA 271 "" 0 "" 
{TEXT 271 123 "AC_inv takes a list that represents a basis vector in t
he tensor algebra and returns the number it is in our ordered basis." 
}}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 434 "AC_inv:=proc(L::list
)\nlocal i,k,l,m,r,s,t,u,n,res,bc;\nk:=nops(L);\nif k=0 then \nreturn(
1)\nfi;\nm:=L[1]-1;\nr:=0;\nfor i from 2 to k do \nif L[i]=m+1 then \n
r:=r+1; \nelif L[i]>m then\nm:=L[i]-1;\nr:=0;\nfi; \nod;\nbc:=[seq(1,i
=1..k)];\nres:=[];\nfor i to k do \nif L[i]=m+1 then \nbc[i]:=0 \nelse
 \nres:=[op(res),L[i]]\nfi;od;\nu:=AC_inv(res);\nt:=BC_inv(bc)-1;\ns:=
u+t*m^(k-r-1);\n#print([m,k,r,s,u,t,res,bc]);\nn:=s+add(binomial(k,l)*
m^(k-l),l=0..r);\nend:\n" }}}{EXCHG {PARA 0 "" 0 "" {TEXT 258 64 "The \+
procedure num_chn computes the number of  chains of degree l" }{TEXT 
-1 0 "" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 45 "num_chn:=proc(l::
nonnegint)\nDIMENSION^l;\nend:" }}}{EXCHG {PARA 258 "" 0 "" {TEXT 258 
63 "The procedure mk_cochn calculates the n-th cochain of degree l." }
}{PARA 259 "> " 0 "" {MPLTEXT 1 259 152 "mk_cochn:=proc(n::posint,l::n
onnegint)\nlocal out, Q,R,N;\nQ:=iquo(n,DIMENSION,'R');\nif R=0 then \+
\nQ:=Q-1;\nR:=DIMENSION \nfi;\nQ:=Q+1;\nout:=[AC(Q,l),R];\nend:" }}}
{EXCHG {PARA 258 "" 0 "" {TEXT 258 61 "The procedure mk_cochns calcula
tes all cochains of degree l. " }}{PARA 259 "> " 0 "" {MPLTEXT 1 259 
134 "mk_cochns:=proc(l::nonnegint)\nlocal i,out;\nout:=[]:\nfor i from
 1 to num_chn(l)*DIMENSION do\nout:=[op(out),mk_cochn(i,l)]\nod;\nout;
\nend:" }}}{EXCHG {PARA 258 "" 0 "" {TEXT 258 70 "The procedure cochn_
inv computes the number n for an arbitrary cochain" }}{PARA 258 "" 0 "
" {TEXT 258 39 "L of degree l such that mk_cochn(n,l)=L" }}{PARA 259 "
> " 0 "" {MPLTEXT 1 259 96 "cochn_inv:=proc(L)\nlocal K,R,Q,n;\nR:=L[2
]:\nK:=L[1]:\nQ:=AC_inv(K):\nQ:=Q-1;\nn:=Q*DIMENSION+R;\nend:" }}}
{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 160 "zmka:=proc()\nlocal i,j
,l:\nglobal a;\nl:=2:\nif nargs<>0 then \nl:=args[1] \nfi:\nfor i from
 1 to DIMENSION do \nfor j from 1 to num_chn(l) do \na[i,j]:=0:\nod;\n
od;\nend:" }}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 163 "zmkaa:=pr
oc()\nlocal i,j,l:\nglobal aa;\nl:=2:\nif nargs<>0 then \nl:=args[1] \+
\nfi:\nfor i from 1 to DIMENSION do \nfor j from 1 to num_chn(l) do \n
aa[i,j]:=0;\nod;\nod;\nend:" }}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 
259 115 "zmkg:=proc()\nlocal i,j;\nglobal g;\nfor i from 1 to DIMENSIO
N do\nfor j from 1 to DIMENSION do\ng[i,j]:=0:\nod:od:\nend: " }}}
{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 244 "umka:=proc()\nlocal i,j
,l;\nglobal a;\nl:=2:\nif nargs<>0 then \nl:=args[1] \nfi:\nfor i from
 1 to DIMENSION do \nfor j from 1 to num_chn(l) do \na[i,j]:=0;\nif pa
rity_tbas(AC(j,l))=parity_elem(i) then\na[i,j]:=0;\nelse \nunassign('a
[i,j]')\nfi;\nod;\nod;\nend:" }}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 
1 259 237 "umkaa:=proc()\nlocal i,j,l:\nglobal aa;\nl:=2:\nif nargs<>0
 then \nl:=args[1] \nfi:\nfor i from 1 to DIMENSION do \nfor j from 1 \+
to num_chn(l) do \nif parity_tbas(AC(j,l))=parity_elem(i) then\naa[i,j
]:=0;\nelse \nunassign('aa[i,j]')\nfi;\nod;\nod;\nend:" }}}{EXCHG 
{PARA 259 "> " 0 "" {MPLTEXT 1 259 242 "umkg:=proc()\nlocal i,j;\nglob
al g;\nfor i from 1 to DIMENSION do\nfor j from 1 to DIMENSION do\ng[i
,j]:=0:\nif (parity_elem(i)=EVEN and parity_elem(j)=EVEN) or (parity_e
lem(i)=ODD and parity_elem(j)=ODD) \nthen \nunassign('g[i,j]') \nfi:\n
od:od:\nend: " }}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 109 "mka:=
proc()\nlocal l;\nl:=2: \nif nargs<>0 then \nl:=args[1] \nfi:\nMatrix(
DIMENSION,num_chn(l),(i,j)->a[i,j])\nend:" }}}{EXCHG {PARA 259 "> " 0 
"" {MPLTEXT 1 259 110 "mkaa:=proc()\nlocal l;\nl:=2: \nif nargs<>0 the
n \nl:=args[1] fi:\nMatrix(DIMENSION,num_chn(l),(i,j)->aa[i,j])\nend:
" }}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 68 "mkg:=proc()\nglobal
 g;\nMatrix(DIMENSION,DIMENSION,(i,j)->g[i,j])\nend:" }}}{EXCHG {PARA 
259 "> " 0 "" {MPLTEXT 1 259 271 "mattoder:=proc(A)\nlocal res,i,j,k,M
,N;\nres:=ZEROCODER;\nN:=ColumnDimension(A):\nk:=log[DIMENSION](N);\ni
f not type(k,nonnegint)then error(\"Improper Matrix Size\")fi;\nM:=Row
Dimension(A):\nfor i from 1 to M do\nfor j from 1 to N do\nres:=ad(res
,mph(AC(j,k),i,A[i,j]));\nod;od;\nend:" }}}{EXCHG {PARA 0 "" 0 "" 
{TEXT -1 401 "The command typet computes the degree of a tensor if it \+
contains monomials of the same degree. It returns an error if the tens
or is not of homogeneous degree. It doesn't return an error in some ca
ses where the input is not a tensor (MISTAKE). This command is only us
ed in the tenstovec command, which itself is only used in the mkb comm
and which is never used. Thus this command is evidently obsolete." }}}
{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 358 "typet:=proc()\nlocal tn
s,i,deg;\nif nargs=0 then \ntns:=ZEROTENS \nelse \ntns:=args[1]\nfi;\n
if not type(tns,list) then \nERROR(\"Tensor is ill defined\")\nfi;\nif
 tns=ZEROTENS then \nreturn(0)\nfi;\ndeg:=nops(tns[1][TMON_BASE]);\nfo
r i from 2 to nops(tns) do\nif nops(tns[i][TMON_BASE])<>deg then \nERR
OR(\"Not all terms in the tensor have the same degree\") \nfi;\nod;\nd
eg;\nend:" }}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 395 "typed:=pr
oc()\nlocal cder,i,deg;\nif nargs=0 then cder:=d \nelse \ncder:=args[1
]\nfi;\nif not type(cder,list) then \nERROR(\"Coderivation is ill defi
ned\")\nfi;\nif cder=ZEROCODER then \nreturn(0)\nfi;\ndeg:=nops(cder[1
][CMON_BASE][CBASE_LIST]);\nfor i from 2 to nops(cder) do\nif nops(cde
r[i][CMON_BASE][CBASE_LIST])<>deg then \nERROR(\"Not all terms in the \+
coderivation have the same degree\") \nfi;\nod;\ndeg;\nend:" }}}
{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 307 "dertomat:=proc(cder::li
st)\nlocal cbas,coef,cmon,l,i,j,m,n,c,A;\nl:=2:\nif nargs>1 then \nl:=
args[2]\nelse \nl:=typed(cder)\nfi;\nn:=num_chn(l);\nm:=DIMENSION;\nA:
=Matrix(m,n,0);\nfor cmon in cder do\ncbas:=cmon[CMON_BASE];\ncoef:=cm
on[CMON_COEF];\nA[cbas[CBASE_INDEX],AC_inv(cbas[CBASE_LIST],l)]:=coef;
\nod;\neval(A);\nend:" }}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 
142 "vectotens:=proc(L::Vector,l::nonnegint)\nif Dimension(L)<>num_chn
(l) then \nERROR(\"Mismatch\") \nfi;\n[seq([AC(i,l),L[i]],i=1..Dimensi
on(L))];\nend:" }}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 227 "vect
oder:=proc(L::Vector,l::nonnegint)\nlocal out,i,k;\nk:=log[DIMENSION](
Dimension(L))-1;\nif not type(k,nonnegint)then error(\"Improper Vector
 Size\")fi;\nout:=ZEROCODER;\nad(seq(mph(op(mk_cochn(i,k)),L[i]),i=1..
Dimension(L)));\nend:" }}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 
273 "tenstovec:=proc(tns::list)\nlocal i,l,n,out;\nif nargs>1 then l:=
args[2]\nelse \nl:=typet(tns)\nfi;\nn:=num_chn(l);\nout:=Vector[row]([
seq(0,i=1..n)]);\nfor i from 1 to nops(tns) do\nout[AC_inv(tns[i][TMON
_BASE],l)]:=out[AC_inv(tns[i][TMON_BASE],l)]+tns[i][TMON_COEF];\nod:\n
out:\nend:" }}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 305 "dertovec
:=proc(cder::list)\nlocal l,i,n,cmon,cbas,coef,out;\nl:=2:\nif nargs>1
 then \nl:=args[2]\nelse \nl:=typed(cder)\nfi;\nn:=DIMENSION*num_chn(l
);\nout:=Vector([seq(0,i=1..n)]);\nfor cmon in cder do\ncbas:=cmon[CMO
N_BASE];\ncoef:=cmon[CMON_COEF];\nout[cochn_inv(cbas,l)]:=out[cochn_in
v(cbas,l)]+coef;\nod:\nout;\nend:" }}}{EXCHG {PARA 259 "> " 0 "" 
{MPLTEXT 1 259 145 "mkphs:=proc(k::nonnegint)\nlocal c,vec;\nif nargs>
1 then \nc:=args[2] \nfi;\nvec:=Vector([seq(c[i],i=1..DIMENSION*num_ch
n(k))]);\nvectoder(vec,k);\nend:" }}}{EXCHG {PARA 0 "" 0 "" {TEXT -1 
344 "The procedure countsol takes a set of linear equalities and count
s the number of such equalities whose left hand side is the same as th
e right hand side. This is used to count the number of free variables \+
which result from applying a linear operator to a generic basis elemen
t, which therefore gives the dimension of the kernel of the operator.
" }}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 122 "countsol:=proc(sol
)\nlocal i,cnt;cnt:=0;\nfor i to nops(sol) do\nif lhs(sol[i])=rhs(sol[
i]) then \ncnt:=cnt+1 fi;\nod;cnt;\nend:" }}}{EXCHG {PARA 0 "" 0 "" 
{TEXT -1 105 "The procedure grabsol does not seem to be used in any of
 the other procedures so it is probably obsolete." }}}{EXCHG {PARA 
259 "> " 0 "" {MPLTEXT 1 259 139 "grabsol:=proc(sol)\nlocal i,res;res:
=[];\nfor i to nops(sol) do\nif lhs(sol[i])=rhs(sol[i]) then \nres:=[o
p(res),lhs(sol[i])] \nfi;\nod;res;\nend:" }}}{EXCHG {PARA 0 "" 0 "" 
{TEXT -1 280 "The procedure sc strips out the coefficients of a coderi
vation and makes them into a set.  It is used as part of the method of
 solving for when the coefficients are zero, which is the key to findi
ng the kernel of the codifferential applied to some generic element of
 fixed degree." }}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 108 "sc:=
proc(cder)\nlocal res,i;\nres:=\{\};\nfor i to nops(cder) do\nres:=\{o
p(res),cder[i][CMON_COEF]\};\nod;\nres;\nend:" }}}{EXCHG {PARA 0 "" 0 
"" {TEXT -1 332 "The procedure mkcoh takes one argument n, which repre
sents the degree of the cochains to be studied. It returns the dimensi
on of the kernel of the coboundary operator applied to cochains of deg
ree n.  It has an optional second argument which represents the name g
iven to the variables used to create the generic cochain of degree n.
" }}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 240 "mkcoh:=proc(n::non
negint)\nglobal d;\nlocal i,j,x,res,ans,sol,vars;\nif nargs>1 then \nx
:=args[2] \nfi;\nres:=tb(d,mkphs(n,x)):\nans:=sc(res);\nvars:=\{seq(x[
i],i=1..DIMENSION*num_chn(n))\};\n#print(ans,vars);\nsol:=solve(ans,va
rs);\ncountsol(sol);\nend:" }}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 
259 386 "cntco:=proc()\nlocal deg,i,k,z,b,h,c,n;\nif type(d,list) then
 \ndeg:=typed(d)\nelse \nerror(\"The codifferential d is not defined\"
)\nfi; \nif nargs>=1 then \nk:=args[1]\nelse \nk:=DIMENSION+1 \nfi;\nf
or i from 0 to k do\nc:=num_chn(i)*DIMENSION;\nz:=mkcoh(i);\nif deg=1 \+
then \nh:=2*z-c;\nelif \ni< deg-1 then \nh:=z:\nelse \nh:=z-b[i-deg+1]
;\nfi;\nb[i]:=c-z:\nprint(\"Cohomology in dimension\",i,\"is\",h);\nod
;\nend:" }}}{EXCHG {PARA 0 "" 0 "" {TEXT -1 202 "The procedure mkq cre
ates the matrix of the extension of the linear automorphism g of the s
pace V to a map from V^k to V^k, where k is the argument of the proced
ure, which must be a nonnegative integer." }}}{EXCHG {PARA 259 "> " 0 
"" {MPLTEXT 1 259 161 "mkq:=proc()\nlocal i,j,k,l,n,A;\nglobal g;\nl:=
2:\nif nargs>0 then \nl:=args[1]fi;\nn:=num_chn(l);\nA:=Matrix(n,n,(i,
j)->product(g[AC(i,l)[k],AC(j,l)[k]],k=1..l)):\nend:" }}}{EXCHG {PARA 
0 "" 0 "" {TEXT -1 100 "The procedure mkb does not appear to be used i
n any of the other procedures so is probably obsolete." }}}{EXCHG 
{PARA 259 "> " 0 "" {MPLTEXT 1 259 339 "mkb:=proc()\nlocal B,l,i,vec,k
,n,m,vecs;\nglobal d;\nif type(d,list) then \nk:=typed(d)\nelse \nerro
r(d,\"is not a codifferential\")\nfi;\nl:=2*k-1:\nif nargs>1 then \nl:
=args[2] \nfi;\nm:=num_chn(l):\nn:=num_chn(l-k+1):\nvecs:=[]:\nB:=Matr
ix([seq(convert(tenstovec(apply_coder_tens(d,mk_tens(mk_tmon((AC(i,l))
))),l-k+1),list),i=1..n)]):\nTranspose(B);\nend:" }}}{EXCHG {PARA 0 "
" 0 "" {TEXT -1 0 "" }}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 384 
"mksol:=proc(vars)\nlocal i,j,neqs,deg,exeq;\nglobal M1,M2,allsol,A,g,
AA;\nexeq:=\{\};\nif nargs>1 then \nexeq:=args[2];\nfi;\nif nargs>2 th
en \ndeg:=args[3]; \nelif \ntype(d,list) then \ndeg:=typed(d); \nelse \+
\ndeg:=2;\nfi;\nM1:=simplify(A.mkq(deg)):\nM2:=mkq(1).AA:\nneqs:=[seq(
seq(M1[i,j]=M2[i,j],i=1..DIMENSION),j=1..num_chn(deg))]:\nallsol:=\{so
lve(\{op(neqs),op(exeq)\},\{op(vars)\})\}:\nnops(allsol);\nend:" }}}
{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 218 "mkm:=proc(L)\nlocal var
,eq,M,i,j,k,l;\nM:=Matrix(DIMENSION,DIMENSION,0);\nfor i from 1 to DIM
ENSION do \nfor j from 1 to DIMENSION do\nfor eq in L do \nvar:=lhs(eq
);\nif var=g[i,j] then \nM[i,j]:=rhs(eq) \nfi;\nod;od;od;\nM;\nend:" }
}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 589 "cksol:=proc()\n local
 i,dt,nosol,tmp;\n global allsol,thsols;\n nosol:=0;\n thsols:=[];\n t
mp:=1:\n if nargs>0 then\n  if args[nargs]='print=false' then tmp:=0 f
i:\n fi;\n for i from 1 to nops(allsol) do  \n  dt:=simplify(Determina
nt(mkm(allsol[i]))):\n  if dt <>0 then\n   nosol:=1;\n   thsols:=[op(t
hsols),i];\n   #print(\"determinant of solution\",i, factor(dt));\n   \+
#print(mkm(allsol[i]));\n  fi;\n od;\n if nosol=0 then \n  if tmp=1 th
en \n   print(\"No Solutions\");\n  fi:\n  return(false);\n else\n  if
 tmp=1 then\n   print(\"The solutions with nonzero determinant are\",t
hsols);\n  fi:\n  return(true);\n fi;\nend:" }}}{EXCHG {PARA 259 "> " 
0 "" {MPLTEXT 1 259 128 "getvars:=proc(A::Matrix)\nlocal i,j,vars;\nva
rs:=\{\};\nindets(\{seq(seq(A[i,j],i=1..RowDimension(A)),j=1..ColumnDi
mension(A))\});\nend:" }}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 
348 "whatrel:=proc(n)\nlocal dt,vartypes,eq,var;\nvartypes:=\{\};\nif \+
nargs=1 and type(exvar,set) then \nvartypes:=exvar; \nelse \nvartypes:
=args[2] \nfi;\nprint(mkm(allsol[n]));\ndt:=simplify(Determinant(mkm(a
llsol[n])));\nprint(determinant=factor(simplify(dt)));\nfor eq in alls
ol[n] do \nfor var in vartypes do\nif lhs(eq)=var then\nprint(factor(e
q))\nfi\nod;\nod;\nend:" }}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 
245 "stg:=proc(M::Matrix) \nglobal g,DIMENSION;\nlocal i,j;\nif RowDim
ension(M)<>DIMENSION or ColumnDimension(M)<> DIMENSION then \nerror(\"
Matrix has wrong size\") fi;\nfor i from 1 to DIMENSION do \nfor j fro
m 1 to DIMENSION do \ng[i,j]:=M[i,j]:\nod;od;\nend:" }}}{EXCHG {PARA 
259 "> " 0 "" {MPLTEXT 1 259 371 "sta:=proc(M::Matrix) \nglobal a,DIME
NSION;\nlocal i,j,k;\nk:=ColumnDimension(M);\nif nargs>1 then \nk:=arg
s[2] \nfi;\nif k<>ColumnDimension(M) then \nerror(\"Matrix has wrong n
umber of columns for stated degree\") \nfi;\nif RowDimension(M)<> DIME
NSION then \nerror(\"Matrix has wrong number of rows\") \nfi;\nfor i f
rom 1 to DIMENSION do \nfor j from 1 to k do \na[i,j]:=M[i,j]:\nod;od;
\nend:" }}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 254 "mkmatrix:=pr
oc(n)\nlocal i,j,deg,M;\nif type(d,list) then \ndeg:=typed(d)else erro
r(\"Can't find the degree of the codifferential\", d) \nfi;\nTranspose
(Matrix([seq(convert(dertovec(tb(d,mph(op(mk_cochn(i,n)))),n+deg-1),li
st),i=1..num_chn(n)*DIMENSION)]));\nend:" }}}{EXCHG {PARA 259 "> " 0 "
" {MPLTEXT 1 259 548 "cnker:=proc(A)\nlocal eq,cnt,C,Y,i,j,m,n,y,vartp
,vars,var;\nglobal THESOL;\nvars:=[];\nif nargs>1 then \nvars:=args[2]
 \nfi;\nm:=RowDimension(A);\nn:=ColumnDimension(A);\nY:=Matrix(n,1,[se
q([y[i]],i=1..n)]);\nC:=A.Y;\nTHESOL:=[solve(\{seq(C[i,1],i=1..m)\})]:
\nprint(\"Number of solutions:\",nops(THESOL));\nfor i from 1 to nops(
THESOL) do\ncnt:=n;vartp:=\{\}; \nfor eq in THESOL[i] do\nfor j from 1
 to n do \nif lhs(eq)=y[j] and rhs(eq)<>y[j] then \ncnt:=cnt-1 \nfi;od
;\nfor var in vars do \nif lhs(eq)=var then \nvartp:=\{op(vartp),eq\}
\nfi;od;\nod;\nprint([i,cnt,vartp]);od;\nend:" }}}{EXCHG {PARA 259 "> \+
" 0 "" {MPLTEXT 1 259 464 "Colbasis:=proc(A::Matrix)\nlocal i,rk,c,r,c
rk,k,nrk,out;\nk:=0;\nout:=[];\nc:=ColumnDimension(A);\nr:=RowDimensio
n(A);\nif nargs>1 and type(args[2],nonnegint) then \nk:=args[2] fi;\ni
f k>c then \nERROR(\"The Column dimension of the matrix is too small\"
) \nfi;\nrk:=0;\nnrk:=0; \nif k>0 then \nrk:=nops(RowSpace(SubMatrix(A
,1..r,1..k))); \nfi;\nfor i from k+1 to c do\nnrk:=nops(RowSpace(SubMa
trix(A,1..r,1..i)));\nif nrk>rk then \nrk:=nrk;out:=[op(out),Column(A,
i)];\nfi;\nod;\nout;\nend:" }}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 
259 597 "cohobasis:=proc(n::nonnegint)\nlocal k,i,cders,res,coh,vars,V
,coc,deg,Y,C,bas;\nif type(d,list) then \ndeg:=typed(d)\nelse \nerror(
\"Can't find the degree of the codifferential\", d) \nfi;\nvars:=\{\}:
\nif nargs=2 and type(args[2],set) then \nvars:=args[2] \nfi;\nV:=mkma
trix(n);\nif vars<>\{\} then \ncnker(V,vars)fi;\ncoc:=[op(NullSpace(V)
)];\nif coc=[] then return([])fi;\nY:=convert(coc,Matrix);\nif n<deg-1
 then\ncders:=map(vectoder,coc,n);\n#map(pc,cders):\nreturn(cders);\nf
i;\nV:=mkmatrix(n-deg+1);\nC:=<<V|Y>>;\nk:=ColumnDimension(V);\ncoh:=C
olbasis(C,k);\ncders:=map(vectoder,coh,n);\n#map(pc,cders):\nreturn(cd
ers);\nend:" }}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 77 "scmat:=p
roc(A::matrix)\n\{seq(seq(A[i,j],i=1..rowdim(A)),j=1..coldim(A))\}:\ne
nd:" }}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 216 "issamevec:=proc
(X::Vector,Y::Vector)\nlocal i,n;\nn:=Dimension(X); \nif Dimension(Y)<
>n then \nerror(\"Vectors have different lengths\")fi;\nfor i from 1 t
o n do\nif X[i]<>Y[i] then \nreturn(false) \nfi;\nod;\nreturn(true);\n
end:" }}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 493 "coboprebasis:=
proc(n::nonnegint)\nlocal i,j,k,V,B,vars,res;\nif type(d,list) then \n
k:=typed(d) \nelse \nerror(d,\"is not a codifferential\")\nfi;\nif n+1
 < k then \nreturn([])\nfi;\nvars:=\{\}:\nif nargs=2 and type(args[2],
set) then \nvars:=args[2] \nfi;\nres:=[];\nV:=mkmatrix(n-k+1);\nif var
s<>\{\} then \ncnker(V,vars)\nfi;\nB:=Colbasis(V);\nfor i from 1 to no
ps(B) do\nfor j from 1 to ColumnDimension(V) do\nif issamevec(B[i],Col
umn(V,j)) then \nres:=[op(res),mph(op(mk_cochn(j,n-k+1)))];\nbreak;\nf
i\nod;\nod;\nres: \nend:" }}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 
259 303 "assignphis:=proc(cders,psi)\nlocal i,k,par;\npar:=1; \nif nar
gs>2 then \npar:=args[3]\nfi;\nunassign('psi');\nk:=1;\nfor i from 1 t
o nops(cders)\ndo \nif parity_cbase(cders[i][CMON_BASE][CBASE_LIST])=p
ar then\npsi[k]:=cders[i];\nk:=k+1;\nfi; \nod;\nfor i from 1 to k-1 do
 \nprint(''psi''[i]=pnt_coder(psi[i])) \nod;\nend:" }}}{EXCHG {PARA 
259 "> " 0 "" {MPLTEXT 1 259 394 "cobobasis:=proc(n::nonnegint)\nlocal
 i,j,k,V,B,res,vars;\nif type(d,list) then \nk:=typed(d) \nelse \nerro
r(d,\"is not a codifferential\")\nfi;\nif n+1 < k then \nreturn([])\nf
i;\nres:=[];\nvars:=\{\}:\nif nargs=2 and type(args[2],set) then \nvar
s:=args[2] \nfi;\nV:=mkmatrix(n-k+1);\nif vars<>\{\} then \ncnker(V,va
rs)\nfi;\nB:=ColumnSpace(V):\nfor i from 1 to nops(B) do\nres:=[op(res
),vectoder(B[i],n)];\nod;\nres: \nend:" }}}{EXCHG {PARA 259 "> " 0 "" 
{MPLTEXT 1 259 136 "gettypes:=proc(L::list,p)\nlocal cder,res;\nres:=[
];\nfor cder in L do\nif parity_coder(cder)=p then \nres:=[op(res),cde
r] \nfi;\nod:\nres:\nend:" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 
2713 "versal:=proc(d)\nlocal i,k,ptst,nogood,j,m,dinf,\ntaus,numdeltas
,numgammas,numbetas,numtaus,numalphas,thebracket;\nglobal t,A,S,ASOL,P
SOL,DINF,RELS,_MaxSols,deltas,alphas,betas,gammas;\nif type(d,list) th
en \nk:=typed(d) \nelse \nerror(d,\"is not a codifferential\")\nfi;\nA
:=dertomat(d,k);\nif nargs>1 then \ndeltas:=gettypes(args[2],1):\nelse
\nprint(\"computing a basis of the cohomology in degree\",k);\ndeltas:
=gettypes(cohobasis(k,getvars(A)),1):\nprint(\"A basis of the cohomolo
gy in degree\",k);\nprint(map(pnt_coder,deltas));\nfi;\nnumdeltas:=nop
s(deltas);\nprint(\"The basis of the cohomology in degree\",k,\"has\",
numdeltas,\"elements.\");\nprint(\"computing a prebasis of the\",2*k-1
,\"coboundaries\");\ngammas:=gettypes(coboprebasis(2*k-1,getvars(A)),1
):\nnumgammas:=nops(gammas);\nprint(\"The prebasis of the coboundaries
 in degree\",k,\"has\",numgammas,\"elements.\");\nbetas:=[seq(mc(tb(d,
gammas[i]),2),i=1..numgammas)];\nprint(\"A basis of the coboundaries o
f degree\",2*k-1);\nprint(map(pnt_coder,betas));\nnumbetas:=nops(betas
);\nprint(\"The basis of the coboundaries in degree\",2*k-1,\"has\",nu
mbetas,\"elements.\");\nif nargs>2 then \nalphas:=gettypes(args[3],0);
 \nelse\nprint(\"computing a basis of the cohomology in degree\",2*k-1
);\nalphas:=gettypes(cohobasis(2*k-1,getvars(A)),0):\nfi;\nnumalphas:=
nops(alphas):\nprint(\"A basis of the cohomology in degree\",2*k-1);\n
print(map(pnt_coder,alphas));\nprint(\"The basis of the cohomology in \+
degree\",2*k-1,\"has\",numalphas,\"elements.\");\nprint(\"computing a \+
prebasis of the\",3*k-2,\"coboundaries\");\ntaus:=gettypes(coboprebasi
s(3*k-2,getvars(A)),0):\nnumtaus:=nops(taus):\nprint(\"The prebasis of
 the coboundaries in degree\",3*k-2,\"has\",numtaus,\"elements.\");\n#
print(map(pnt_coder,taus));\ndinf:=ad(d,seq(mult_coder_num('t'[i],delt
as[i]),i=1..numdeltas),seq(mult_coder_num('x'[i],gammas[i]),i=1..numga
mmas)):\nthebracket:=dertovec(tb(dinf,dinf)):\nprint(\"Computing the m
atrix of the versal deformation\");\nA:=ReducedRowEchelonForm(Matrix([
seq(dertovec(alphas[i]),i=1..numalphas),seq(dertovec(betas[i]),i=1..nu
mbetas),seq(dertovec(taus[i]),i=1..numtaus),thebracket]));\nRELS:=[seq
(A[i,numalphas+numbetas+numtaus+1],i=1..numalphas)];\nS:=\{seq(A[i,num
alphas+numbetas+numtaus+1],i=numalphas+1..numalphas+numbetas)\};\nASOL
:=\{\};\nprint(\"Solving for the x variables\");\nPSOL:=simplify([solv
e(S,\{seq('x'[i],i=1..numgammas)\})]);\nfor i from 1 to nops(PSOL) do
\nptst:=subs(seq(x[m]=0,m=1..numgammas),seq(t[m]=0,m=1..numdeltas),PSO
L[i]);\n#print(ptst);\nnogood:=0:\nfor j from 1 to nops(ptst)\ndo\nif \+
rhs(ptst[j])<>0 then nogood:=1;break;fi:\nod:\nif nogood=0 then ASOL:=
PSOL[i]:break;fi;\nod:\nprint(ASOL);#return;\nprint(\"Computing the ve
rsal deformation\");\nRELS:=\{op(subs(ASOL,RELS))\};\nDINF:=psubs(ASOL
,dinf):\nprint(\"Versal Deformation Computed\"):\nend:" }{TEXT -1 0 "
" }}}{EXCHG {PARA 272 "" 0 "" {TEXT 272 96 "The procedure ckit compare
s one codifferential versus all of the codifferentials in a dimension.
" }}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 1751 "ckit:=proc(der)\n
 local num,i,j,x,y,z,w,excond,exvars,mytype,svars,Mat1,Mat2,neqs,omit,
lvout,pnt;\n global A,AA,G,Q,vars,thsols,allsol,whichsol,MAXTYPE,_MaxS
ols;\n _MaxSols:=10000;\n AA:=dertomat(der,2);\n if nargs>1 then mytyp
e:=args[2];\n elif thetype<>\"\" then mytype:=thetype;\n else ERROR(\"
No type file to search specified\");\n fi:\n pnt:=typeoptions(initial=
[0,0],seq(args[i],i=1..nargs)):\n if nargs>2 then if nops(args[3])=1 t
hen x:=args[3]; fi;fi;\n if nargs>3 then if nops(args[4])=1 then y:=ar
gs[4]; fi;fi:\n if nargs>4 then if nops(args[5])=1 then z:=args[5]; fi
;fi;\n if nargs>5 then if nops(args[6])=1 then w:=args[6]; fi;fi;\n ex
vars:=\{\};\n omit:=\{\};\n if nargs>6 then \n  if type(args[7],set) t
hen \n   omit:=args[7]; \n  fi;\n fi;\n whichsol:=[];  \n for i from 1
 to mytype() do\n  if pnt[1]=1 then\n   print(\"Checking type\",i);\n \+
 fi;\n  if omit<>\{\} then\n   lvout:=0; \n   for j in omit do \n    i
f i=j then \n     if pnt[1]=1 then\n      print(\"omitting type\",i);
\n     fi;\n     lvout:=1;\n     break;\n    fi;\n   od;\n   if lvout=
1 then lvout:=0;next;fi;\n  fi:\n  if pnt[1]=1 then  \n   A:=dertomat(
mytype(i,x,y,z,w,print=true,shiftit=pnt[2]));\n  else\n   A:=dertomat(
mytype(i,x,y,z,w,print=false,shiftit=pnt[2]));\n  fi;\n  umkg();G:=mkg
():Q:=mkq():\n  vars:=\{op(exvars),op(getvars(A)),op(getvars(AA)),op(g
etvars(G))\};\n  svars:=\{op(exvars),op(getvars(A)),op(getvars(AA))\};
\n  excond:=\{\};\n  Mat1:=simplify(evalm(simplify(A&*Q))):\n  Mat2:=e
valm(G&*AA):\n  neqs:=[seq(seq(Mat1[i,j]=Mat2[i,j],i=1..DIMENSION),j=1
..num_chn(2))]:\n  allsol:=\{solve(\{op(neqs),op(excond)\},vars)\}:\n \+
 if pnt[1]=1 then \n   if cksol() then whichsol:=[op(whichsol),i] fi;
\n  else\n   if cksol(print=false) then whichsol:=[op(whichsol),i] fi;
\n  fi:\n od;\n print(\"The types with solutions are\",whichsol);\nend
:" }}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 1510 "ckit:=proc(der)
\n local num,i,j,x,y,z,w,excond,exvars,mytype,svars,Mat1,Mat2,neqs,omi
t,lvout,pnt;\n global A,AA,G,Q,vars,thsols,allsol,whichsol,MAXTYPE,_Ma
xSols;\n _MaxSols:=10000;\n AA:=dertomat(der,2);\n if nargs>1 then myt
ype:=args[2];\n elif thetype<>\"\" then mytype:=thetype;\n else ERROR(
\"No type file to search specified\");\n fi:\n pnt:=typeoptions(initia
l=[0,0],seq(args[i],i=1..nargs)):\n if nargs>2 then if nops(args[3])=1
 then x:=args[3]; fi;fi;\n if nargs>3 then if nops(args[4])=1 then y:=
args[4]; fi;fi:\n if nargs>4 then if nops(args[5])=1 then z:=args[5]; \+
fi;fi;\n if nargs>5 then if nops(args[6])=1 then w:=args[6]; fi;fi;\n \+
exvars:=\{\};\n omit:=\{\};\n if nargs>6 then \n  if type(args[7],set)
 then \n   omit:=args[7]; \n  fi;\n fi;\n whichsol:=[];  \n for i from
 1 to mytype() do\n  if i in omit then next fi;\n  if pnt[1]=1 then\n \+
    print(\"Checking type\",i);\n  fi;\n  A:=dertomat(mytype(i,x,y,z,w
,print=false,shiftit=pnt[2]));\n  umkg();G:=mkg():Q:=mkq():\n  vars:=
\{op(exvars),op(getvars(A)),op(getvars(AA)),op(getvars(G))\};\n  svars
:=\{op(exvars),op(getvars(A)),op(getvars(AA))\};\n  excond:=\{\};\n  M
at1:=simplify(A.Q):\n  Mat2:=simplify(G.AA):\n  neqs:=[seq(seq(Mat1[i,
j]=Mat2[i,j],i=1..DIMENSION),j=1..num_chn(2))]:\n  allsol:=\{solve(\{o
p(neqs),op(excond)\},vars)\}:\n  if pnt[1]=1 then \n   if cksol() then
 whichsol:=[op(whichsol),i] fi;\n  else\n   if cksol(print=false) then
 whichsol:=[op(whichsol),i] fi;\n  fi:\n od;\n print(\"The types with \+
solutions are\",whichsol);\nif nops(whichsol)>0 then return(true)else \+
return(false)fi;\nend:" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" 
}}}{EXCHG {PARA 272 "" 0 "" {TEXT 272 73 "The routine below is used af
ter the routine above to obtain the relations" }}}{EXCHG {PARA 0 "> " 
0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 
586 "compare:=proc(der1,der2)\nlocal num,i,x,y,z,w,excond,exvars,svars
,Mat1,Mat2,neqs;\nglobal A,AA,G,Q,vars,thsols,allsol,_MaxSols;\n_MaxSo
ls:=10000;\nAA:=dertomat(der2,2);\nexvars:=\{\};if nargs>2 then exvars
:=args[3]fi;  \nA:=dertomat(der1,2);\nprint(evalm(A),evalm(AA));\numkg
();G:=mkg():Q:=mkq():\nvars:=\{op(exvars),op(getvars(A)),op(getvars(AA
)),op(getvars(G))\};\nsvars:=\{op(exvars),op(getvars(A)),op(getvars(AA
))\};\nexcond:=\{\};\nMat1:=AA.Q:\nMat2:=G.A:\nneqs:=[seq(seq(Mat1[i,j
]=Mat2[i,j],i=1..DIMENSION),j=1..num_chn(2))]:\nallsol:=\{solve(\{op(n
eqs),op(excond)\},vars)\}:\ncksol():\n#allrels2(svars);\nend:" }}}
{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 588 "ncompare:=proc(der1,der
2)\nlocal num,i,x,y,z,w,excond,exvars,svars,Mat1,Mat2,neqs;\nglobal A,
AA,G,Q,vars,thsols,allsol,_MaxSols;\n_MaxSols:=10000;\nAA:=dertomat(de
r2,2);\nexvars:=\{\};if nargs>2 then exvars:=args[3]fi;  \nA:=dertomat
(der1,2);\n#print(evalm(A),evalm(AA));\numkg();G:=mkg():Q:=mkq():\nvar
s:=\{op(exvars),op(getvars(A)),op(getvars(AA)),op(getvars(G))\};\nsvar
s:=\{op(exvars),op(getvars(A)),op(getvars(AA))\};\nexcond:=\{\};\nMat1
:=AA.Q:\nMat2:=G.A:\nneqs:=[seq(seq(Mat1[i,j]=Mat2[i,j],i=1..DIMENSION
),j=1..num_chn(2))]:\nallsol:=\{solve(\{op(neqs),op(excond)\},vars)\}:
\ncksol():\n#allrels2(svars);\nend:" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 272 "" 0 "" {TEXT 272 86 "The routin
e below is used after the routine above, it displays the relavent rela
tions." }}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 258 "showrel:=pro
c()\nlocal num,L,exvars;\nglobal A,AA,G,Q,vars,thsols;\nL:=thsols;if n
args>0 then L:=args[1]fi;\nexvars:=\{\};if nargs>1 then exvars:=args[2
]fi;\nfor num in L\ndo\nprint(\"working on\",num);\nwhatrel(num,\{op(e
xvars),op(getvars(A)),op(getvars(AA))\});\nod:\nend:" }}}{EXCHG {PARA 
271 "" 0 "" {TEXT 271 70 "The routine below shifts the codifferential'
s elements up at least one" }}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 
259 684 "shiftit:=proc(cder)\n local out,n,cmon,coef,cod,i,ncod,j,k;\n
 if cder=ZEROCODER then return ZEROCODER fi;\n n:=1:\n if nargs>1 then
 n:=args[2] fi:\n out:=[]:\n if type(n,integer) then\n  for cmon in cd
er do\n   coef:=cmon[2];\n   cod:=cmon[1];\n   ncod:=[]:\n   for i to \+
nops(cod[1]) do\n    ncod:=[op(ncod),cod[1][i]+n]:\n   od;\n   out:=ad
(out,mph(ncod,cod[2]+n,coef)):\n  od;\n  return(out);\n fi;\n if type(
n,list) then\n  out:=cder;\n  for i to nops(n) do\n   for j to nops(cd
er) do\n    cmon:=cder[j][1];\n    for k to nops(cmon[1]) do\n     if \+
cmon[1][k]=i then\n      out[j][1][1][k]:=n[i];\n     fi;\n    od;\n  \+
  if cmon[2]=i then \n     out[j][1][2]:=n[i];\n    fi;\n   od;\n  od;
\n return(out);\n fi; \nend:" }}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 
1 259 49 "psubs:=proc(subseq,lst)pad(subs(subseq,lst)):end:" }}}
{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 402 "allrels2:=proc()\nlocal
 num, eq, var, vars,slop,AAA;\nglobal A,AA,thsols, allsol;\nvars:=\{\}
:if nargs>0 then vars:=args[1]fi;\nfor num in thsols do \nprint(\"work
ing on \",num):\nslop:=\{op(map(convert,[op(allsol[num])],radical))\}:
\nAAA:=mkm(slop):\nprint(AAA):\nprint(determinant=factor(simplify(Dete
rminant(AAA))));\nfor eq in slop do \nfor var in vars do\nif lhs(eq)=v
ar then\nprint(simplify(eq))\nfi\nod;\nod;\nod;\nend:" }}}{EXCHG 
{PARA 259 "> " 0 "" {MPLTEXT 1 259 606 "mk_ker:=proc(A::Matrix)\nlocal
 r,n,i,j,pivots,lastpivot,nulls,dims,res,B,vec,nullbas;\ndims:=Dimensi
on(A):\nlastpivot:=0;\npivots:=[];\nnullbas:=[];\nnulls:=[];\nB:=Reduc
edRowEchelonForm(A):\nfor i from 1 to dims[1]\ndo\nfor j from lastpivo
t+1 to dims[2]\ndo\nlastpivot:=j;\nif B[i,j]<>0 then \npivots:=[op(piv
ots),j];\nbreak;\nfi;\nnulls:=[op(nulls),j];\nod;\nod;\nnulls:=[op(nul
ls),seq(i,i=lastpivot+1..dims[2])];\nr:=nops(pivots);\nn:=nops(nulls);
\nfor j from 1 to n\ndo\nvec:=Vector([seq(0,i=1..dims[2])]);\nfor i fr
om 1 to r\ndo\nvec[pivots[i]]:=-B[i,nulls[j]];\nod;\nvec[nulls[j]]:=1;
\nnullbas:=[op(nullbas),vec];\nod;\nnullbas:\nend:" }}}{EXCHG {PARA 
273 "> " 0 "" {MPLTEXT 1 273 571 "Colbasis:=proc(A::Matrix)\nlocal B,i
,rk,c,r,dims,k,pivots,lastpivot,j;\nk:=0;lastpivot:=0;pivots:=[];\ndim
s:=[Dimension(A)];\n#c:=ColumnDimension(A);\n#r:=RowDimension(A);\nif \+
nargs>1 and type(args[2],nonnegint) then k:=args[2] fi;\nif k>dims[2] \+
then ERROR(\"The Column dimension of the matrix is too small\")fi;\nB:
=ReducedRowEchelonForm(A):\nfor i from 1 to dims[1]\ndo\nfor j from la
stpivot+1 to dims[2]\ndo\nif B[i,j]<>0 then \nif j>k then pivots:=[op(
pivots),j]fi;\nlastpivot:=j;\nbreak;\nfi;\nlastpivot:=j;\nod;\nif last
pivot=dims[2] then break fi;\nod;\nreturn([Column(A,pivots)]);  \nend:
" }}}{EXCHG {PARA 273 "> " 0 "" {MPLTEXT 1 273 172 "facent:=proc(A::Ma
trix)\nlocal i,j,B;\nB:=Matrix(Dimension(A)):\nfor i from 1 to RowDime
nsion(A)do\nfor j from 1 to ColumnDimension(A)do\nB[i,j]:=factor(A[i,j
]):\nod;\nod:\nB;\nend:" }}}{EXCHG {PARA 273 "> " 0 "" {MPLTEXT 1 273 
401 "extend:=proc(init)\nlocal i,tmp,tp,len,out,a;\ntmp:=[];\nout:=[]:
\nif init=[] then len:=0:else len:=nops(init[nops(init)]);fi:\nfor i t
o nops(init) \ndo\nif nops(init[i])=len then tmp:=[op(tmp),init[i]]:fi
;\nod;\nif len<PARITY then out:=[op(out),[op(tmp[1]),0]]fi;\nfor tp in
 tmp do\nif (add(tp[i],i=1..nops(tp))<(DIMENSION-PARITY) and nops(tp)<
DIMENSION-1) \nthen   \nout:=[op(out),[op(tp),1]]:\nfi:\nod:\nout:\nen
d: " }}}{EXCHG {PARA 273 "> " 0 "" {MPLTEXT 1 273 395 "mkgM:=proc()\nl
ocal L,gM,i,eL,oL,nume,numo,j;\nL:=[[]]:\nfor i to DIMENSION-1 do L:=[
op(L),op(extend(L))]:od;\nL:=[seq(L[i],i=2..nops(L))];\ngM:=L:\neL:=[s
eq(i,i=1..PARITY)]:\noL:=[seq(i,i=PARITY+1..DIMENSION)]:\nfor i to nop
s(L) do\nnume:=1:\nnumo:=1:\nfor j to nops(L[i]) do\nif L[i][j]=0 then
\ngM[i][j]:=eL[nume]:\nnume:=nume+1:\nfi:\nif L[i][j]=1 then \ngM[i][j
]:=oL[numo]:\nnumo:=numo+1:\nfi:\nod:\nod:\ngM;\nend:" }}}{EXCHG 
{PARA 273 "> " 0 "" {MPLTEXT 1 273 217 "mkgW:=proc(M1)\nlocal M,W,i,gW
,j;\ngW:=[]:\nfor j to nops(M1) do\nM:=sort(M1[j]):\nW:=[seq(i,i=1..DI
MENSION)];\nfor i to nops(M) do\nW[M[i]]:=0:\nod:\nW:=[op(\{op(W)\})]:
\nW:=[seq(W[i],i=2..nops(W))];\ngW:=[op(gW),W]:\nod;\ngW:\nend:" }}}
{EXCHG {PARA 273 "> " 0 "" {MPLTEXT 1 273 999 "gmaps:=proc(M1::list)\n
local ind,i,j,k,tmp;\nglobal M,W,glambda,gpsi,gbeta;\nif nops(M1)>DIME
NSION-1 or nops(M)<0 then error(\"M is too large or small\")fi:\nM:=so
rt(M1):\nW:=[seq(i,i=1..DIMENSION)];\nfor i to nops(M) do\nW[M[i]]:=0:
\nod:\nW:=[op(\{op(W)\})]:\nW:=[seq(W[i],i=2..nops(W))];\nglambda:=ZER
OCODER:\ngpsi:=ZEROCODER:\ngbeta:=ZEROCODER:\nind:=1:\nfor i to nops(W
) do\nfor j to nops(W) do\nfor k to nops(M) do\ntmp:=mph([W[i],W[j]],M
[k],c[ind]):\nif parity_coder(tmp)=1 then;\ngpsi:=ad(gpsi,tmp):\nind:=
ind+1:\nfi:\nod:\nod:\nod:\nind:=1:\nfor i to nops(W) do\nfor j to nop
s(M) do\ntmp:=mph([W[i]],M[j],b[ind]):\nif parity_coder(tmp)=0 then;\n
gbeta:=ad(gbeta,tmp):\nind:=ind+1:\nfi:\nod:\nod:\nmkdeltamu(M,W):\nGe
nG(M,W):\nnmkglambda();\nif nargs>1 and (args[2]='banana' or args[2]='
print') then  \n#print('lambda'=pnt_coder(glambda)):\nprint(mklmat(gla
mbda)):\nprint('psi'=pnt_coder(gpsi)):\nprint('beta'=pnt_coder(gbeta))
:\nprint(\"mu=mytypeM\"=mytypeM):\nprint(\"delta=mytypeW\"=mytypeW):\n
print('M'=M);\nprint('W'=W);\nprint('G'=G);\nfi;\nend:" }}}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 1817 "restrictions:=proc(mu,delta,M1::l
ist)\nlocal i,anslam,ansmc,lambda,bracdlp,bracmc,ans,psi,mbcobound,ans
l:\nglobal TH:\nbracdlp:=proc(delta,lambda,psi)\nlocal dl, ans,temp,i;
\ndl:=ad(delta,lambda):\nans:=[op(\{solve(sc(tb(dl,psi)))\})]:\ntemp:=
[]:\nif ans=[] then\nreturn([[lambda,psi]]):\nelse\nfor i to nops(ans)
 do\ntemp:=[op(temp),[subs(ans[i],lambda),subs(ans[i],psi)]]:\nod:\nfi
:\nreturn(temp):\nend:\nbracmc:=proc(delta,mu,lambda,psi)\nlocal ans,t
emp,i;\nans:=[op(\{solve(sc(ad(tb(delta,lambda),mc(tb(lambda,lambda),1
/2),tb(mu,psi))))\})];\ntemp:=[]:\nif ans=[] then \nreturn([[lambda,ps
i]]);\nelse\nfor i to nops(ans) do\ntemp:=[op(temp),[subs(ans[i],lambd
a),subs(ans[i],psi)]];\nod:\nfi:\nreturn(temp):\nend:\nmbcobound:=proc
(res)\nlocal i,result,ans,dum,mbco,j;\nresult:=res;\nfor i to nops(res
ult) do\nmbco:=ad(tb(mu,gbeta),result[i]):\nans:=[op(\{solve(sc(mbco))
\})]:\nif tb(mu,gbeta)<>ZEROCODER then\ndum:=[1,nops(mbco)]:\nfor j to
 nops(ans) do\nif nops(subs(ans[j],mbco))<dum[2] then\ndum:=[j,nops(su
bs(ans[j],mbco))]:\nfi;\nod;\nif ans<>[] then\nresult[i]:=subs(ans[dum
[1]],mbco):\nfi:\nfi:\nod;\n  result:=[op(\{op(result)\})];\n end:\n g
maps(M1):\n ansl:=[op(\{solve(sc(tb(mu,glambda)))\})]:\n anslam:=[]:\n
 if ansl=[] then\n  anslam:=[glambda]:\n else\n  for i to nops(ansl) d
o \n   lambda:=subs(ansl[i],glambda): \n   anslam:=[op(anslam),lambda]
: \n  od:\n fi:\n anslam:=mbcobound(anslam):\n ansmc:=[]: \n for i to \+
nops(anslam) do   \n   lambda:=anslam[i]:\n   ansmc:=[op(ansmc),op(bra
cmc(delta,mu,lambda,gpsi))];\n od:\n ans:=[]:\n for i to nops(ansmc) d
o\n   ans:=[op(ans),op(bracdlp(delta,ansmc[i][1],ansmc[i][2]))]:\n od:
\n if nargs>3 then \n  if args[4]='print' then\n   for i to nops(ans) \+
do\n    print('lambda'=pnt_coder(ans[i][1]));\n    print('psi'=pnt_cod
er(ans[i][2]));\n    print(\"-----------------------------------------
-------------------\"):\n   od;\n  fi;\n fi;\n ans:\nend:" }}}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 137 "mkd:=proc(clist)\n local out,i:\n \+
out:=[]:\n for i to nops(clist) do;\n  out:=[op(out),ad(delta,mu,clist
[i][1],clist[i][2])];\n od;\n out;\nend:" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 89 "parity_base:=proc(tbas::list)\n nops(tbas)-add(parity
_elem(tbas[i]),i=1..nops(tbas));\nend:" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 311 "mkdeltamu:=proc(M,W)\n global mytypeM,mytypeW;\n if \+
parity_base(M)=nops(M) then\n  mytypeM:=atypex0;\n else\n  mytypeM:=at
ype||(parity_base(M))||(nops(M)-parity_base(M));\n fi:\n if parity_bas
e(W)=nops(W) then\n  mytypeW:=atypex0;\n else  \n  mytypeW:=atype||(pa
rity_base(W))||(nops(W)-parity_base(W));\n fi;\n return;\nend:" }}}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 157 "GenG:=proc()\n local i,j;\n
 global g,G,M,W;\n umkg():\n for i to nops(M) do\n  for j to nops(W) d
o\n   g[M[i],W[j]]:=0;g[W[j],M[i]]:=0:\n  od;\n od;\n G:=mkg();\n end:
" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 35 "fsubs:=proc()factor(sub
s(args))end:" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 2640 "deform:=p
roc(d,n)\nlocal alp,alphas,gam,gammas,bet,betas,tau,taus,res,res1,ans,
dinf,tst,i,j,zerox,thes,ans1;\nglobal t,DINF,RELS,Z,ZZ;\nprint(\"Compu
ting a basis of the 2-cocycles\"):\nres:=gettypes(cohobasis(2),1);\npr
int(map(pnt_coder,res));\ndinf:=factor(ad(d,seq(mc(res[i],t[i]),i=1..n
ops(res)))):\npc(dinf);\ntst:=pad(factor(tb(dinf,dinf))):\nif tst=ZERO
CODER then\nprint(\"The infinitesimal deformation is versal and there \+
are no relations\"):\nDINF:=dinf;RELS:=\{\}:\nreturn():\nfi;\nprint(\"
Computing a basis of the 3-cocycles\"):\nalp:=gettypes(cohobasis(3),0)
:print(map(pnt_coder,alp));\nalphas:=ad(seq(mc(alp[i],-r[i]),i=1..nops
(alp))):\nprint(\"Computing a prebasis of the 3-coboundaries\"):\ngam:
=gettypes(coboprebasis(3),1):\ngammas:=ad(seq(mc(gam[i],x[i]),i=1..nop
s(gam))):\nprint(\"Computing a basis of the 3-coboundaries\"):\nbet:=[
seq(mc(tb(d,gam[i]),-2),i=1..nops(gam))]:\nbetas:=ad(seq(mc(tb(d,gam[i
]),2*s[i]),i=1..nops(gam))):\nprint(\"Computing a prebasis of the 4-co
boundaries\"):\ntau:=gettypes(coboprebasis(4),0):\nprint(\"The number \+
of 4-coboundaries is\",nops(tau));\ntaus:=ad(seq(mc(tau[i],u[i]),i=1..
nops(tau))):\nprint(\"Computing the versal deformation\");\nDINF:=ad(d
inf,gammas);\nres:=ad(tb(DINF,DINF),betas,alphas,taus);\nans:=solve(sc
(res),\{seq(r[i],i=1..nops(alp)),seq(s[i],i=1..nops(gam)),seq(u[i],i=1
..nops(tau))\});\nRELS:=subs(ans,\{seq(r[i],i=1..nops(alp))\}):\nZZ:=[
seq(0,i=1..nops(gam))];\nres1:=subs(seq(x[i]=0,i=1..nops(gam)),ans);\n
for j from 1 to n do:\nprint(\"Computing the\",j,\"th order deformatio
n\");\nZ:=factor(subs(res1,[seq(s[i],i=1..nops(gam))]));\nprint('Z'=Z)
:\nif Z=[seq(0,i=1..nops(gam))]\nthen\nprint(\"The versal deformation \+
is given by the\", j,\"th order deformation\"):\nDINF:=pad(factor(subs
(seq(x[i]=ZZ[i],i=1..nops(gam)),DINF)));\n#RELS:=subs(res1,\{seq(r[i],
i=1..nops(alp))\});\nRELS:=subs(seq(x[i]=ZZ[i],i=1..nops(gam)),RELS);
\nprint(\"Versal Deformation Computed\");\nreturn():\nfi;\nfor i from \+
1 to nops(gam) do ZZ[i]:=ZZ[i]+Z[i];od;\nres1:=subs(seq(x[i]=ZZ[i],i=1
..nops(gam)),ans);\nod;\n#print('Z'=subs(res1,[seq(s[i],i=1..nops(gam)
)]));\n#ZZ:=subs(res1,[seq(u[i],i=1..nops(tau))]);\n#pc(subs(seq(u[i]=
ZZ[i],i=1..nops(tau)),taus));\nprint(\"Versal Deformation not given by
 the\",n,\"order deformation, attempting to compute it another way.\")
;\nZ:=factor(subs(res1,[seq(s[i],i=1..nops(gam))]));\nzerox:=\{\};\nfo
r i from 1 to nops(gam) do if ZZ[i]=0 then zerox:=\{op(zerox),x[i]=0\}
 fi od;\nthes:=subs(ans,[seq(s[i],i=1..nops(gam))]);\nprint([zerox,the
s]);\nprint(\"solving for the x variables\");\nans1:=solve(\{op(zerox)
,op(thes)\},\{seq(x[i],i=1..nops(gam))\});\nDINF:=pad(factor(subs(ans1
,DINF)));\nRELS:=\{op(subs(ans1,RELS))\};\nprint(\"Versal deformation \+
Computed\");\nend:" }{TEXT -1 0 "" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 428 "findopp:=proc()\nlocal coef,omit,cmon,cbas,clist,cin
d,der,nder;\nglobal d;\nif nargs<>0 then der:=args[1];else der:=d;fi;
\nomit:=\{\};if nargs>1 then omit:=args[2];fi;\nnder:=ZEROCODER;\nfor \+
cmon in der do\ncbas:=cmon[1];\nclist:=cbas[1]:\ncind:=cbas[2]:\ncoef:
=sgn(parity_tbas(cbas[1]))*cmon[2];\nnder:=ad(nder,mph([clist[2],clist
[1]],cind,coef)):\nod;\npc(nder):\nif nargs>1 then ckit(nder,thetype,x
,y,z,w,omit):else ckit(nder):fi;\nnder;\nend:" }}}{EXCHG {PARA 0 "> " 
0 "" {MPLTEXT 1 0 249 "ckans:=proc(n)\nlocal eqn,res;\nres:=\{seq(fsub
s(seq(t[i]=0,i=1..100),lhs(ans[n][i]))=fsubs(seq(t[i]=0,i=1..100),nume
r(rhs(ans[n][i]))),i=1..nops(ans[n]))\};\nprint(res):\nfor eqn in res \+
do if lhs(eqn)<>rhs(eqn) then return(false)fi;od;\nreturn(true):\nend:
" }}}{EXCHG {PARA 259 "> " 0 "" {MPLTEXT 1 259 346 "ncntco:=proc()\nlo
cal deg,i,k,res,odds;\nif type(d,list) then \ndeg:=typed(d)\nelse \ner
ror(\"The codifferential d is not defined\")\nfi; \nif nargs>=1 then \+
\nk:=args[1]\nelse \nk:=DIMENSION+1 \nfi;\nfor i from 0 to k do\nres:=
cohobasis(i):\nodds:=gettypes(res,1):\nprint(sprintf(`Cohomology in di
mension %d is %d|%d`,i,nops(res)-nops(odds),nops(odds)));\nod;\nend:" 
}}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}}{EXCHG {PARA 0 "> " 
0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }
}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 
"" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 "
" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 "
" {MPLTEXT 1 0 0 "" }}}}{MARK "15 2 11 0 0" 71 }{VIEWOPTS 1 1 0 1 1 
1803 1 1 1 1 }{PAGENUMBERS 0 1 2 33 1 1 }
